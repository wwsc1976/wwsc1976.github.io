<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-us">
<head>
<meta name="viewport" content="width=device-width"> 
<meta m_harset="utf-8" />
<title>Music Reference</title>
<style>

        body, html { margin:0; }
            select { font-size:2.60vw; }
             input { vertical-align:middle; font-size:2.4vw; }

           .radBtn { width:2.4vw; height:2.4vw; }

           .thInst { font-size:2.4vw; padding:2.4vw; }
           .tdInst { font-size:2.4vw; vertical-align:middle; padding:2.4vw; }
            .tdRec { font-size:2.4vw; white-space:nowrap; }

          .tabLink { background-color:#555; color:white; float:left; border:none; outline:none; cursor:pointer; padding:0.729vw 0.833vw; font-size:2.4vw; height:4.6vw; }
        
    .tabLink:hover { background-color:#777; }
       .tabContent { color:black; display:none; padding:1vw 1vw; width:100%; }

      .tdSideChord { width:3vw; }
        .tdVersion { font-size:1.8vw; }

         .fretCell { font-size:1.042vw; position:relative; color:#000044; text-align:center; height:2.3vw; }
     .fretCellInfo { font-size:0.7vw; }
     .fretCellLeft { font-size:0.938vw; position:absolute; top:1.344vw; left:0.1vw; color:#000044;}
    .fretCellRight { font-size:0.938vw; position:absolute; top:1.344vw; right:0.1vw; color:#000044; } 
       .fretString { outline:thin solid lightsteelblue; cursor:pointer; }
         .fretPlay { outline:thin solid lightsteelblue; cursor:pointer; font-size:1.042vw; text-align:center; height:2.3vw; }
         .fretMark { font-size:0.938vw; text-align:center; }

       .pianoWhite { position:absolute; top:0; width:4vw; height:20vw; background-color:white; border:0.052vw solid black; }
   .pianoWhiteText { position:absolute; top:16vw; left:0.2vw; width:3.6vw; font-size:1.4vw; text-align:center; color:black; background-color:white; border:none; }

       .pianoBlack { position:absolute; top:0; width:2.4vw; height:13vw; background-color:black; }
   .pianoBlackText { position:absolute; top:9vw; left:0.2vw; width:2.0vw; font-size:1.4vw; text-align:center; color:white; background-color:black; border:none; }

      .pianoPWhite { position:absolute; top:0; width:2vw; height:10vw; background-color:white; border:0.052vw solid black; }
  .pianoPWhiteText { position:absolute; top:8vw; left:0.1vw; width:1.8vw; font-size:0.7vw; text-align:center; color:black; background-color:white; border:none; }

      .pianoPBlack { position:absolute; top:0; width:1.2vw; height:6.5vw; background-color:black; }
  .pianoPBlackText { position:absolute; top:4.5vw; left:0.1vw; width:1.0vw; font-size:0.7vw; text-align:center; color:white; background-color:black; border:none; }

        .chordInfo { font-size:1.042vw; padding:0.521vw; color:#000044; cursor:pointer; border:0.2vw solid lime; }
        .scaleInfo { font-size:1.022vw; padding:0.501vw; color:#000044; }
        .modeChord { border:0.052vw solid lightsteelblue; width:1.823vw; text-align:center; cursor:pointer; border:0.2vw solid lime; }
        .chordNote { font-size:1.042vw; border:0.2vw solid limegreen; width:1.823vw; text-align: center; cursor:pointer; }
     .chordFormula { text-align:center; font-style:italic; font-size:0.93vw; }
        .chordStep { text-align:center; font-size:0.93vw; }
     .modeSequence { text-align:center; font-style:italic; font-size:0.938vw; }
        .scaleName { font-size:1.042vw; padding:0.501vw; }
        .scaleNote { border:0.052vw solid lightsteelblue; width:2.823vw; text-align:center; cursor:pointer; }
     .spanPatInKey { border:0.2vw solid limegreen; cursor:pointer; }

  .tableChordsRoot { border-spacing:0.9vw; }
     .tdChordsRoot { font-size:2.40vw; vertical-align:middle; text-align:center; width:4.0vw; height:3.2vw; border-radius:0.26vw; border:0.052vw solid black; cursor:pointer; color:black; background-color:#e9e9e9; }
               
    .tdHarmonyInst { font-size:2.2vw; }    
              .btn { font-size:2.55vw; font-weight:400; }
         .btnScale { font-size:2.55vw; font-weight:400; color:lime; cursor:pointer; }
          .btnBuff { font-size:2.55vw; font-weight:400; width:11.8vw; }

     .tdPlayBuffer {  }
       .divRecBuff { overflow-x:scroll; }
   .tdRecBuffScale { font-size:0.8vw; }
   .tdRecChordNote { font-size:0.9vw; background-color:red; color:white; cursor:pointer; }
  .tdRecBuffOctave { cursor:pointer; color:blue; }
  .tdRecordBuffTop { cursor:pointer; background-color:lime; }
  .tdRecordBuffBot { cursor:pointer; background-color:red; }
  .tdRecordBufferN { font-size:1.042vw; padding:0.521vw; color:#000044; cursor:pointer; border:0.2vw solid cyan; display:inline-block; height:6.0vw; }
  .tdRecordBufferC { font-size:1.042vw; padding:0.521vw; color:#000044; cursor:pointer; border:0.2vw solid blue; display:inline-block; height:6.0vw; }
  .tdRecordBufferS { font-size:1.042vw; padding:0.521vw; color:#000044; border:0.2vw solid red; text-align:center; display:inline-block; height:6.0vw; }
          .divPlay { font-size:0.84vw; border:0.001vw solid navy; text-align:center; color:black; }
           .tdPlay { overflow:hidden; display:inline-block; white-space:nowrap; }
       .tdPlayArea { overflow:scroll; }
        .tdMeasure { border: 0.2vw solid blue; }
        .tdQuarter { border: 0.2vw solid red; width:0.4vw; border-style:none solid none none; }
      .tdSixteenth { background-color:skyblue; border:0.2vw solid lightgray; cursor:pointer;  }
     .divSixtennth { display:inline-block; position:relative; height:3vw; width:3vw; }
   .tdPlayBuffMain { font-size:1.042vw; background-color:gray; background-color:black; color:white; width:2.4vw; margin:auto; height:1.2vw; text-align:center; }
   .tdPlayBuffTime { font-size:0.7vw;  top:1.7vw; background-color:black; color:lime; width:2.4vw; margin:auto; text-align:center; }
    .tdPlayBuffVol { font-size:0.7vw;  top:2.3vw; background-color:black; color:lime; width:2.4vw; margin:auto; text-align:center; }


  .tableDlgPattern { border-spacing:2vw; }
     .tdDlgPattern { font-size:2.50vw; vertical-align:middle; text-align:center; width:32.0vw; height:4.0vw; border-radius:0.26vw; border:0.052vw solid black; cursor:pointer; color:black; background-color:#e9e9e9; }

       .dialogBase { display:none; vertical-align:top; position:fixed; z-index:1; left:0; top:0; width:100vw; height:100vh; overflow:visible; background-color:rgb(0,0,0); background-color:rgba(0,0,0,0.4); } /* opacity */
           .dialog { background-color:#fefefe; margin:7vw auto; padding:0.104vw; border:0.052vw solid #888; width:90vw; }
 
</style>
<script type="text/javascript">

//@ts-check

// special characters 

var symSharp= '\u266F'; // Arial unicode MS  sharp symbol
var symFlat=  '\u266D'; // flat symbol
var symDim7=  '\u00F8'; // 0 with slash
var symFDim=  '\u00B0'; // degree symbol
var symMajor= '\u25B3'; // delta symbol
var symDot =  '\u25CF'; // dot
var symNote = '\u266B'; // 2 notes
var symNot =  '\u2205'; // circle with line thru it
var symFwd =  '\u25BA'; // arrow pointing >
var symBack = '\u25C4'; // arrowing pointing <
var sym8th =  '\u266A'; // 8th note
var symBlock= '\u2588'; // full block;

// measurements in vw & vh viewport units

var fretStartSize = 5;         // 80 pixels on 1920 x 1200
var fretBeforeNut = 2.604;     // 50 pixels
var fretDecrease = 0.110;      // 2 pixel
var fretMarkStart = 3.126;     // 60 pixels, slid over to line up dots
var fretMarkBeforeNut = 1.562; // 30 pixels

var pianoWhiteWidth = 4;   // width of a white piano key in "vw" viewport units  ( 4 = 4% of the view port width
var pianoWhiteHeight = 20; // height
var pianoBlackWidth = 2.8; // width of a black piano key

var optFingeringNumbers = 1;
var optFingeringLetters = 2;

var blueNote = "#6FA8DC"; // a light blue

/////////////////////////////
//    Global Variables
/////////////////////////////

var m_Version = "1.2.8";     
var m_Audio = null;             // used in frequency generation for gui items clicked on
var m_CurrentWave = "square";   // sine square triangle sawtooth
var m_CurrentVolume = 0;        // obtained from volume control

var m_CurrentChordPattern = -1; // index to m_arrChordPatterns, set when cbo dropdown is changed
var m_CurrentKey = -1;          // index to m_arrModes.KeyList array, used to generate m_Key Key object
var m_CurrentMode = -1;         // index to m_arrModes, set when a cboMode dropdown is changed  
var m_CurrentInstrument = -1;   // index to m_arrInstruments, set when radio button is clicked
var m_CurrentChordRoot = null;  // set when generated chord root note TD is clicked in Chord section, chord type dialog is popped and chord is generated, Note object
var m_CurrentScale = -1;        // index to m_arrScales array, scales such as the blues and pentatonic

var m_CurrentGuitarCapo = 0;    // all set when capo drop downs are changed
var m_CurrentBassCapo = 0;
var m_CurrentMandolinCapo = 0;
var m_CurrentUkuleleCapo = 0;

var m_CurrentGuitarTuning = 0;   // all set when tuning dropdowns are changed
var m_CurrentBassTuning = 0;
var m_CurrentMandolinTuning = 0;
var m_CurrentUkuleleTuning = 0;
var m_CurrentKeyboardTuning = 0;
var m_CurrentFingeringOption = optFingeringNumbers;  // whether to show numbers 1234 or letters IMRP for chord fingerings

var m_CurrentGUIThing = -1;   // index into m_arrGUIPlay
var m_CurrentPlayBuffer = 0;  // index into the m_arrPlayBuffer array
var m_CurrentPlayTime = 1000; // milliseconds per measure
var m_CurrentPlayPercLenth = 0.50; // percentage of time to hold a note playing,

var m_MasterVol;              // master volume from 1st tab 
var m_GUITime = 1200;         // 1600 milliseconds for each "whole" note

var m_CurrentTimeSignature;    // 1 thru 4   1 = 4/4  2 = 3/4  3 = 2/4  4 = 6/8
var m_CurrentPlaySixteenth=0;  // which 16th note of a play buffer is selected

var m_PlaySixteenthIndex = -1;    // sound engine 16th note counter
var m_PlaySixteenthCount = 120;   // number of 16th notes in each m_arrPlayBuffer array
var m_PlaySixteenthEnd = 0;       // find the last thing added to in any of the m_arrPlayBuffer arrays

var m_RecordMode = false;   // controlled by chkRecord in Compose section, when items are clicked they are added to Record buffer rather than being played
var m_IsLoading = true;     // so events aren't acted upon when form data is processed and controls are set

var m_Key = null;    // set to a Key object when a key is selected, contains list of notes in the key
var m_Scale = null;  // set to SimpleScale object when a scale is selected, contains list of notes in the scale, the name etc

var m_Guitar = 0;  // instrument index values for m_arrInstruments
var m_Bass = 1;
var m_Mandolin = 2;
var m_Ukulele = 3;
var m_Keyboard = 4;

var m_cpMajor=0;  // these variables can be used to access the specific elements of the m_arrChordPatterns array
var m_cpMinor=1;  // these must match the same set of variables in the GuitarCode C# program
var m_cpSus2=2;
var m_cpSus=3;
var m_cpAug=4;
var m_cpDim=5;
var m_cpMajor6=6;
var m_cpMinor6=7;
var m_cpMajor7=8;
var m_cpMinor7=9;
var m_cpDom7=10;
var m_cpHalfDim7=11;
var m_cpDim7=12;
var m_cpMajor9=13;
var m_cpMinor9=14;
var m_cpDom9=15;

// arrays

var m_arrGuitarBarre = [];      // array of guitar barre chords
var m_arrBassBarre = [];        // bass
var m_arrMandolinBarre = [];    // mandolin barre chords
var m_arrUkuleleBarre = [];     // ukulele, these contain BarrePlacement objects

var m_arrInstruments = [];      // ID, Name, # of strings, # of frets

var m_arrChordPatterns = [];    // ID, Name, ShortName, Pitches, PitchCount, Root, Third, Fifth, Seventh, Ninth, Formula
var m_mapMidiNotes = new Map();
var m_mapPlayInst = new Map();  // used to show instrument board notes during play
var m_arrMidiNotesHL = [];      // ID, Number, Offset, Octave, Frequency, MidiName, Name
var m_arrMidiNotesLH = [];      // Same as above
var m_arrModes = [];            // ID, ModeName, Sequences (steps), ChordType (the pattern), Background (color), KeyList (list of Note objects for key choice dropdown)
var m_arrScales = [];           // ID, Background (color, ScaleName, Sequences (steps), KeyList, LetterSteps (steps between letters)

var m_arrGuitar = [];           // 2D array of midi notes for instrument fretboards
var m_arrBass = [];
var m_arrMandolin = [];
var m_arrUkulele = [];

// blue green gradient color array

var m_arrGradientBlueGreen = ["#189753", "#1ea55c", "#24b266", "#2ac06f", "#30cc79", "#36da82", "#42f696", "#50ffa0"];


// array of pastel colors for chord notes (now using the above color array instead)

// var m_arrPastels = ["#b2cefe", "#baed91", "#faf884", "#f2a2e8", "#e0ffff"]; //blue, green, yellow, pink, cyan  

var m_arrGUIThings = [];    // gui sound engine array, contains PlayThing objects, indexed by m_CurrentPlaySet
var m_arrRecordBuffer = []; // array of PlayThings that user can add to a play buffer staff array
var m_arrPlayBuffers = [];  // array of PlayThing objects maintained by the record section
var m_arrPlayInstTDs = [];  // a list of tds that need to set to "", they were the last play slice notes that were shown

var m_arrFingering = []; // array of fingering, either numbers 1 2 3 4 or letter I M R P. Loaded when option changes.

var m_arrMajorKeys = [];  // passed to Mode constructor, contains a list of Note objects that the mode presents as a Key selection
var m_arrMinorKeys = [];

//////////////////////////////////
//   Object Class Construction
//////////////////////////////////

class Instrument
{
 constructor(id, name, strings, frets)  // ID m_Guitar etc,   "Guitar", # of strings, # of frets
  {
   this.ID = id;
   this.InstrumentName = name;
   this.Strings = strings;         // number of strings
   this.Frets = frets;             // number of frets
   this.Tunings = [];     // tuning arrays  
  }
}

class Tuning
{
 constructor(id, tuningName, arrMidiNotes) 
  {
   this.TuningID = id;
   this.TuningName = tuningName;
   this.TuningMidiNotes = arrMidiNotes;  // array of midi notes, starting with top string (low E on guitar)
  }
}

class Note
{
 constructor(iOffset, letter, sharpOrFlat) // offset int (c=0), letter string C, D, etc, sharpOrFlat string (#, b or "")
  {
   var offset;

   if (iOffset > 11)
     offset = iOffset - 12;
   else 
     offset = iOffset;
   
   this.Offset = offset;           // 0 = C
   this.SharpFlat = sharpOrFlat;   // bb, b, "", #, or ##.  This routine will not produce either bbb or ###
   if (sharpOrFlat != null)        // note is not in key
    {
     this.Letter = letter;           // C thru B
     switch(this.SharpFlat)          // set Text to the letter and proper # or b symbol
      { 
       case "bb": this.Text = letter + symFlat + symFlat;   this.SharpFlatOffset = -2; break; // -2 thru 2
       case "b":  this.Text = letter + symFlat;             this.SharpFlatOffset = -1; break;
       case "":   this.Text = letter;                       this.SharpFlatOffset = 0;  break;
       case "#":  this.Text = letter + symSharp;            this.SharpFlatOffset = 1;  break;
       case "##": this.Text = letter + symSharp + symSharp; this.SharpFlatOffset = 2;  break;
       default: throw new Error("function Note(offset, letter, sharpOrFlat) invalid sharpOrFlat value"); 
      }
    }
   else
    {
     this.Text = letter; // sharpOrFlat was null, the note is out of key, Text will be D#/Eb style
    }
  }
 NextNote(step)  // object function that returns the next Note object in the current mode from this note based on the step
  {                              // this is used by the Key object to generate a list of notes in the key where the notes of the key always increment to the next letter
   var next;                     // so starting from the root each new note will be the next note letter in the series, eg D E F# G A B C#.  Sharps & Flats added as necessary.
   var nType; // 1=EF & BC          some modes end up with very wild sharp flat setups, check out gypsy minor results.

   if (this.SharpFlat == null)
     throw new Error("Note is not in key");

   if (step<1 || step>3)
     throw new Error("Note.NextNote(step) - step out of range"); // currently none of the modes have steps greater then 3
   switch(this.Letter)
    {
     case "C": next = "D"; nType = 2; break;  // this is fairly straight forward
     case "D": next = "E"; nType = 2; break;
     case "E": next = "F"; nType = 1; break;
     case "F": next = "G"; nType = 2; break;
     case "G": next = "A"; nType = 2; break;
     case "A": next = "B"; nType = 2; break;
     case "B": next = "C"; nType = 1; break;
     default: throw new Error("Note.NextNote(step) Invalid Note.Letter value");
    }
   if (nType == 2) // nType is the distance between note letters, E to F and B to C is 1, but all others are 2
    {
     switch(step) // 1 2 or 3
      {
       case 1:
        {
         switch(this.SharpFlat)
          {
           case "bb": throw new Error("Dbbb?");                     // may need to enable this, not sure, problem is all these case statemments are coded for up to bb and ##
           case "b":  return new Note(this.Offset + 1, next, "bb"); // Cb to Dbb so nType = 2 (e.g. C to D), step = 1, so C has to go to D, C to D is 2 steps, so extra b is added 
           case "":   return new Note(this.Offset + 1, next, "b");  // C to Db, C natural + 1 is Db, fairly easy
           case "#":  return new Note(this.Offset + 1, next, "");   // C# to D, C# + 1 is a natural D
           case "##": return new Note(this.Offset + 1, next, "#");  // C## To D#
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat");  
          }
        } 
       case 2:
        {
         switch(this.SharpFlat)
          {
           case "bb": return new Note(this.Offset + 2, next, "bb"); // Cbb to Dbb, step 2 if fairly simple, all the flats and sharps are carried over to the next note letter
           case "b":  return new Note(this.Offset + 2, next, "b");  // Cb to Db
           case "":   return new Note(this.Offset + 2, next, "");   // C to D
           case "#":  return new Note(this.Offset + 2, next, "#");  // C# to D#
           case "##": return new Note(this.Offset + 2, next, "##"); // C## To D##
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } 
       case 3:
        {
         switch(this.SharpFlat)
          {
           case "bb": return new Note(this.Offset + 3, next, "bbb"); // Cbb to Dbbb, 3 steps is only found in Gypsy Minor
           case "b":  return new Note(this.Offset + 3, next, "bb");  // Cb to Dbb
           case "":   return new Note(this.Offset + 3, next, "b");   // C to Db
           case "#":  return new Note(this.Offset + 3, next, "");  // C# to D
           case "##": return new Note(this.Offset + 3, next, "#"); // C## To D#
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } 
      }
    }
   else 
    {
     switch(step)  // this handles going from E to F and B to C.  These notes are next to each other.
      {
       case 1: // 1 step to next note, this time we are working with E to F and B to C
        {
         switch(this.SharpFlat)
          {
           case "bb": return new Note(this.Offset + 1, next, "bb");  // Ebb to Fbb, so 1 step here is like 2 steps above, all sharps and flats carry over to C and F
           case "b":  return new Note(this.Offset + 1, next, "b");   // Eb to Fb
           case "":   return new Note(this.Offset + 1, next, "");    // E to F
           case "#": return new Note(this.Offset + 1,  next, "#");    // C## To D#
           case "##": return new Note(this.Offset + 1, next, "##");    // C## To D#
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } 
       case 2: // step == 2
        {
         switch(this.SharpFlat) // again, the next note always must be the next letter in the series regardless of step or the number of steps between the letters
          {
           case "bb": return new Note(this.Offset + 2, next, "b"); // Ebb to Fb, Ebb + 2 = Fb, going up 2, what F equivlent for Ebb + 2,  Ebb Eb E, what F = E, it's Fb   
           case "b":  return new Note(this.Offset + 2, next, "");  // Eb to F, up 2
           case "":   return new Note(this.Offset + 2, next, "#");   // E to F#
           case "#":  return new Note(this.Offset + 2, next, "##");  // E# to F##
           case "##": throw new Error("F### ?");                     // not going to do ###s or bbb's
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } 
       case 3: // step == 3
        {
         switch(this.SharpFlat)
          { 
           case "bb": return new Note(this.Offset + 2, next, "");  // Ebb to F
           case "b":  return new Note(this.Offset + 2, next, "#");  // Eb to F#
           case "":   return new Note(this.Offset + 2, next, "##");   // E to F##
           case "#":  return new Note(this.Offset + 2, next, "###");  // E# to F###
           case "##": throw new Error("F### ?");                     
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } 
      }
    } 
  }
} 

// chord pattern consists of a name and an array of pitches

class ChordPattern
{
 constructor(id, strName, strAbbrev, arrPitches, arrNames)
  {
   this.ID = id;                           // unique id
   this.Name = strName;                    // Major, Minor, Dorian etc
   this.ShortName = strAbbrev;             // symbols etc
   this.Pitches = arrPitches;              // array of distances of chord notes from the chord's root note, integers
   this.PitchNames = arrNames;             // array of strings denoting the short name of each note of a chord, root, major third, perfect 5th etc
 
   // Finger Placements, these arrays are imported from the c# program "GuitarChord", the .js is copied and pasted below quite a ways down in the code

   this.PatternGuitar = [];
   this.PatternBass = [];
   this.PatternMandolin = [];
   this.PatternUkulele = [];
   this.PatternKeyboard = [];

   this.Root="";
   this.Third="";
   this.Fifth="";
   this.Seventh="";
   this.Ninth="";

   switch(arrPitches[0])
    {
     case 0: this.Root="1";   break;
     case 1: this.Root="#1";  break;
     case 2: this.Root="##1"; break;
    }

   switch(arrPitches[1])
    {
     case 2: this.Third="bb3"; break;
     case 3: this.Third="b3";  break;
     case 4: this.Third="3";   break;
     case 5: this.Third="#3";  break;
     case 6: this.Third="##3"; break;
    }

   switch(arrPitches[2])
    {
     case 5: this.Fifth="bb5"; break;
     case 6: this.Fifth="b5";  break;
     case 7: this.Fifth="5";   break;
     case 8: this.Fifth="#5";  break;
     case 9: this.Fifth="##5"; break;
    }

   switch(arrPitches[3])
    {
     case 9: if (this.Name=="Dim 7th") this.Seventh="bb7"; else this.Seventh="6"; break;
     case 10: this.Seventh="b7";  break;
     case 11: this.Seventh="7";   break;
     case 12: this.Seventh="#7";  break;
     case 13: this.Seventh="##7"; break;
    }

   switch(arrPitches[4])
    {
     case 12: this.Ninth="bb9"; break;
     case 13: this.Ninth="b9";  break;
     case 14: this.Ninth="9";   break;
     case 15: this.Ninth="#9";  break;
     case 16: this.Ninth="##9"; break;
    }

   this.Formula=this.Root;
 
   if (this.Third != "")   this.Formula+="-"+this.Third;
   if (this.Fifth != "")   this.Formula+="-"+this.Fifth;
   if (this.Seventh != "") this.Formula+="-"+this.Seventh;
   if (this.Ninth != "")   this.Formula+="-"+this.Ninth;
  }
}

// Fingering object are stored in the Placement and BarrePlacement object below

class Fingering
{
 constructor(str, fret)
  {
   this.Str = str;    // string number, top string is 0 (low E on guitar)
   this.Fret = fret;  // fret number
  }
}

// Fingering for the barre chord index finger, it has the ShowNote property when true the Index finger's note info is part of the chord and displayed

class BarreIndex
{
 constructor(str, fret, showNote) // this object is only stored in the instrument barre fingering array
  {
   this.Str = str;
   this.Fret = fret;
   this.ShowNote = showNote;  // 1, show the note, it's part of the cord, 0, don't show the note, just show the "I"
  }
} 

// placements, chord fingerings

class Placement
{
 constructor(id, instrument, offset, arrIndex, arrMiddle, arrRing, arrPinky, arrOpen, arrNoPlay)
  {
   this.ID = id;
   this.Instrument = instrument;  // m_Guitar etc
   this.Offset = offset;          // C = 0
   this.Index = arrIndex;         // list of Fingering for the index finger
   this.Middle = arrMiddle;       // middle finger
   this.Ring = arrRing;
   this.Pinky = arrPinky;
   this.Open = arrOpen;           // open notes on either the nut or capo
   this.NoPlay = arrNoPlay;       // string shouldn't be played, it's note is not part of the chord or the string's note is not the root of the chord such as E string in the case of A major chord
  }
}

// C C#/Db D D#/Eb E  F  F#/Gb G G#/Ab A A#/Bb B/Cb
// 0   1   2   3   4  5    6   7   8   9  10    11

// Barre pattern placement
// The way this can show barre chords on the entire fretboard is by the "Offsets" array. The array contains the shift distance up the fret it would take to play the chord
// For example: with the A major pattern to play a chord such as D major the D offset "2" is used to look up the Offset in the OFfsets array which results in "4" 
// so the A major pattern needs to be moved up 4 frets to play a D major.  The shift upwards is not from the nut, but rather from the 1st fret "Bb major" position of the barre chord.
// the Bb major lookup B offset is 10.  The 10 Offsets array result is 0, the A major barre from Bb doesn't need to slide up.    

class BarrePlacement
{
 constructor(id, offset, chordPattern, instrument, arrIndex, arrMiddle, arrRing, arrPinky, arrNoPlay)
  {
   var i, k, fa;

   this.ID = id;                  // unique id
   this.Offset = offset;          // c=0
   this.CP = chordPattern;        // m_cpMajor = 0
   this.Instrument = instrument;  // m_Guitar etc
   switch(offset)
    {
     case 9: // is it the A pattern?
       this.Offsets = [2,3,4,5,6,7,8,9,10,11,0,1,2,3];   // Bb B C Db D -  steps to take to wrap around to C.  14 entries, how far the barre's can go up the fretboard
       break;
     case 4: // E
       this.Offsets = [7,8,9,10,11,0,1,2,3,4,5,6,7,8];   // F Gb G Ab A Bb B C, starting from E next note is F  to wrap F to C is 7 steps
       break;
     case 2: // D
       this.Offsets = [9,10,11,0,1,2,3,4,5,6,7,8,9,10];   // Eb E F Gb G Ab A Bb B C, starting from D next note is Eb, to wrap Eb to C is 9 steps
       break;
     case 0: // C
       this.Offsets = [11,0,1,2,3,4,5,6,7,9,9,10,11,0];   // Db D Eb E F Gb G Ab A Bb B C, starting from C next note is Db, wrapping Db to C is 11 
       break;
    }
   this.Index = [];  // store finger positions for each barre chord starting with 1st barre above  Bb for the A pattern, F for the E pattern
   this.Middle = [];
   this.Ring = [];
   this.Pinky = [];
   this.NoPlay = []; // no open strings

   // Fingering objects are a bit different than the above placements
   // Index Fingering.Fret = 0  and all others are # of frets past the Index 
   // so the barre chord can moved about on the fretboard

  for (i=1; i<14; i++)  // for A major barre starting with Bb for the A pattern and F for the E pattern, they are stored in the array at index 0
    {
     fa = [];
     for (k=0; k<arrIndex.length; k++)
       fa[k]= new BarreIndex(arrIndex[k].Str, arrIndex[k].Fret + i, arrIndex[k].ShowNote);
     this.Index[i-1] = fa;
    }
   for (i=1; i<14; i++)
    {
     fa = [];
     for (k=0; k<arrMiddle.length; k++)
       fa[k]= new Fingering(arrMiddle[k].Str, arrMiddle[k].Fret + i);
     this.Middle[i-1] = fa;
    }
   for (i=1; i<14; i++)
    {
     fa = [];
     for (k=0; k<arrRing.length; k++)
       fa[k]= new Fingering(arrRing[k].Str, arrRing[k].Fret + i);
     this.Ring[i-1] = fa;
    }
   for (i=1; i<14; i++)
    {
     fa = [];
     for (k=0; k<arrPinky.length; k++)
       fa[k]= new Fingering(arrPinky[k].Str, arrPinky[k].Fret + i);
     this.Pinky[i-1] = fa;
    }
   for (i=1; i<14; i++)
    {
     fa = [];
     for (k=0; k<arrNoPlay.length; k++)
       fa[k]= new Fingering(arrNoPlay[k].Str, arrNoPlay[k].Fret + i);
     this.NoPlay[i-1] = fa;
    }
  }
}

// a midi note consists of the midi number, offset distance from "C", the octive, and frequency plus functions to generate the name
// the Name object function returns the note's name based on the current Key, if sharp or flat it will return either #  or b based on the notes of the key
// the MidiName object function returns the name along with the midi note's octave as well, 48 would return C3

class MidiNote
{
 constructor(id, nMidi, nOffset, nOctive, fFreq)
  {
   this.ID = id;             // unique id
   this.Number = nMidi;      // midi note C4 = 60
   this.Offset = nOffset;    // C = 0
   this.Octave = nOctive;    // 4 is middle C
   this.Frequency = fFreq;   // in hertz
  }
 Name(key) // name does not contain octive numbers
  {
   var note;
   
   note = key.OffsetNote(this.Offset);
   if (note == null)
     return NoteText(this.Offset);
   else 
     return note.Text; 
  }   
 MidiName(key) 
  {
   var note;

   note = key.OffsetNote(this.Offset);
   if (note == null)
     return NoteText(this.Offset) + "(" + this.Octave.toString() + ")";
   else
     return note.Text + this.Octave.toString(); 
  };
 MidiNameViaNote(note)
  {
   if (note == null)
     return NoteText(this.Offset) + "(" + this.Octave.toString() + ")";
   else
     return note.Text + this.Octave.toString(); 
  }
}

// modes: ionian, dorian etc

class Mode
{
 constructor(nNdx, sBGColor, sName, arrPitches, arrChordType, arrKeyList) 
  {
   this.ID=nNdx;                  // unique id
   this.ModeName=sName;           // ionian, dorian etc
   this.Sequences=arrPitches;     // list of steps, pitches between chords, Major is 2,2,1,2,2,2,1
   this.ChordType=arrChordType;   // list of chord types for each chord in the mode, Major is m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,cDim
   this.Background=sBGColor;      // background color in the combo box drop down
   this.KeyList = arrKeyList;     // Array of key "Note" objects to display for the mode
  }
}

// oddball scales that are not traditional modes, blues, pentatonics etc

class Scale
{
 constructor(id, sBGColor, sName, arrPitches, arrLookups) 
  {
   this.ID = id;                       // unique id, not really used, should probably remove it
   this.Background = sBGColor;         // dropdown color, only works on PC browsers
   this.ScaleName = sName;             // name of the scale, "Blues Major"
   this.Sequences = arrPitches;        // list of steps between notes
   this.LookUps = arrLookups;          // a index into the m_Key.Notes array and the next note formula 
  }
}

// key signature

class Key
{
 constructor(mode, startNote) // mode index, starting Note object
  {
   var os, i, found, k;

   this.Offset = startNote.Offset;  // c = 0
   this.Mode = mode;
   this.Notes = [];        // list of note names with special characters for sharps and flats
   this.Offsets = [];      // offset notes of the key
   this.LookUp = [];       // a way to find the note name in the key only knowing what the offset is C = 0

   this.BaseMidi = GetBaseMidiNote(startNote.Offset);

   os = startNote.Offset;       // get the key's starting note offset, c = 0
   this.Offsets[0] = os;
   this.Notes[0] = startNote;   // add the 1st note of the key
   for (i=1; i<m_arrModes[mode].Sequences.length; i++)          // add the next  notes of key, start with 1
    {
     this.Notes[i] = this.Notes[i-1].NextNote(m_arrModes[mode].Sequences[i-1]); // populate the Notes array
     os += m_arrModes[mode].Sequences[i-1];   // move to the next offset based on the current mode's pitch sequence
     if (os >= 12)        // if offset >= 12 
       os -= 12;          // wrap it back around to 0
     this.Offsets[i] = os; // populate the Offsets array
    }

   for (i=0; i<12; i++) // build a list of all 12 offsets with the appropriate index of notes in this key, entries of offsets of notes not in this key will be -1 
    {
     found = false;
     for (k=0; k<this.Offsets.length; k++) 
      {
       if (i == this.Offsets[k])
        {
         this.LookUp.push(k);  // save the index to the this.Notes array
         found = true;
        }
      }
     if (found == false)
       this.LookUp.push(-1); // offset of note is not in this key
    }
  }
 OffsetNote(offset) // return Note object
  {
   if (this.LookUp[offset] >=0)
     return this.Notes[this.LookUp[offset]];
   else
    {
     return null;
    }
  }
 NoteIndex(note) // note object, returns index into note array
  {
   var i;

   for (i=0; i<this.Notes.length; i++)
    {
     if (note.Offset == this.Notes[i].Offset)
       return i;
    }
   return -1;
  }
}

class PlayNote
{
 constructor(midiNum, text) // midi num, text
  {
   this.Midi = m_mapMidiNotes.get(midiNum);
   this.Text = text;
  }
}

// since this function can be called after a chord is placed all the values to reconstruct it have to be available at runtime, can't rely on m_Key or m_CurrentMode.

class PlayChord
{
 constructor(mode, keyNdx, patNdx, midiBase) // mode ndx, key index into a mode's keylist array (can be -1), chord pattern index, midi starting note
  {
   var key, text, note, midi;
   var k, m;

   this.Mode = mode;
   this.KeyIndex = keyNdx;
   this.Pattern = patNdx;
   this.Notes = [];

   if (keyNdx >= 0)
     key = new Key(mode, m_arrModes[mode].KeyList[keyNdx]);
   else
     key = null;

   for (k=0; k<m_arrChordPatterns[patNdx].Pitches.length; k++)
    {
     m = midiBase + m_arrChordPatterns[patNdx].Pitches[k];
     midi = m_mapMidiNotes.get(m);
     if (key == null)
       text = NoteText(midi.Offset);
     else
      {
       note = key.OffsetNote(midi.Offset);
       if (note == null)
         text = NoteText(midi.Offset);
       else
         text = note.Text;
      }
     this.Notes[k] = new PlayNote(m, text);
    }

   this.Text = this.Notes[0].Text + m_arrChordPatterns[patNdx].ShortName;
  }
}

class PlayScale
{
 constructor(mode, keyNdx, midiBase, otherScale) // mode index, index into mode.KeyList array, midi note of tonic, index into m_arrScales (can be < 0)
  {
   var i, k, midiNum;
   var key, note, next, notes, ndx;  // generate array of PlayNote objects
   var midi;

   this.Mode = mode;
   this.KeyIndex = keyNdx;
   this.MidiBase = midiBase;
   this.OtherScale = otherScale;

   key = new Key(mode, m_arrModes[mode].KeyList[keyNdx]); // build the key

   midiNum = midiBase;  // start from the intrument's base note 

   notes = [];

   if (otherScale<0) // is it an other scale?  m_arrScales
    {
     this.Text = m_arrModes[mode].ModeName;               // nope, it's a mode 
     for (i=0; i<m_arrModes[mode].Sequences.length; i++)  // go thru the mode's sequences
      {
       notes[i] = new PlayNote(midiNum, key.Notes[i].Text); // add the PlayNote from the key
       midiNum += m_arrModes[mode].Sequences[i];            // next note
      }
     notes.push(new PlayNote(midiNum, key.Notes[0].Text)); // add the tonic octave
    }
   else
    {
     this.Text = m_arrScales[otherScale].ScaleName;  
     for (i=0; i<m_arrScales[otherScale].Sequences.length; i++) // other scale, blues and such
      {
       midi = m_mapMidiNotes.get(midiNum);             // get Midi object
       note = null;
       for (k=0; k<key.Notes.length; k++)              // see if note is in key
        {
         if (key.Notes[k].Offset == midi.Offset)
          note = key.Notes[k];                       // it is, grab the Note object to obtain text
        }
       if (note != null)                               // was it found?
         notes[i] = new PlayNote(midiNum, note.Text);  // yes, add the PlayNote object for it
       else
        {
         if (m_arrScales[otherScale].LookUps[i] != null)  // no, note wasn't found in key, see if the other scale has an adaption for a key Note object, aka raise 2nd
          {
           ndx = m_arrScales[otherScale].LookUps[i][0];  // grab the index to the key object Note array from other scale that needs to be adapted (aka Blues raise 2nd note)
           note = key.Notes[ndx];                                       // get the key Note object to alter
           next = note.NextNote(m_arrScales[otherScale].LookUps[i][1]); // perform the scale operation to alter the note
           notes[i] = new PlayNote(midiNum, next.Text);                 // add the Play note for the altered note
          }
         else
          {
           note = new Note(midi.Offset, NoteText(midi.Offset), null);  // So there wasn't an adaption entry for a key Note object
           notes[i] = new PlayNote(midiNum, note.Text);           // just use the C#/Db notation
          }
        }
       midiNum += m_arrScales[m_CurrentScale].Sequences[i];  // next note
      }
     notes.push(new PlayNote(midiNum, key.Notes[0].Text));   // push the tonic's octave
    }
   this.Notes = notes; // finish the constructor
  }
}

class RecordThing
{
 constructor(recordType, note, chord, scale)
  {
   this.RecordType = recordType;  // N note, C chord, S scale
   this.Note = note;              // PlayNote object, can be null based on above type
   this.Chord = chord;            // PlayChord object, can be null
   this.Scale = scale;            // PlayScale object, can be null
  }
}

class PlayThing
{
 constructor(playThingType, note, chord, wave, vol, time) // N C R, mode ndx, key Object, chord pat ndx, array of PlayNote, wave form text, volume, delay.
  {
   this.PlayType = playThingType;  // N note, C chord, R rest
   this.Note = note;               // PlayNote object, can be null based on type
   this.Chord = chord;             // PlayChord object, can be null
   this.WaveType = wave;           // text, either 'square', 'triangle', 'sine' etc
   this.Volume = vol;              // value obtained from volume control
   this.Time = 1/time;             // 1/1 = whole note, 1/2=half, 1/4=quarter, 1/8=eighth note, 1/16=sixteenth note
   this.DisplayTime = time;        // unaltered version of time
  }
}

//////////////////////////////////
//   Array Building Functions
//////////////////////////////////

function makeInstruments()
{
 var i;

 m_arrInstruments[m_Guitar] = new Instrument(m_Guitar, "Guitar", 6, 24); // 6 strings 24 frets
 m_arrInstruments[m_Guitar].Tunings[0] =  new Tuning(0, "Standard Tuning", [40, 45, 50, 55, 59, 64]); // E2 A2 D3 G3 B3 E4  midi notes
 m_arrInstruments[m_Guitar].Tunings[1] =  new Tuning(1, "Half-Step Down", [39, 44, 49, 54, 58, 63]);
 m_arrInstruments[m_Guitar].Tunings[2] =  new Tuning(2, "Full-Step Down", [38, 43, 48, 53, 57, 62]);
 m_arrInstruments[m_Guitar].Tunings[3] =  new Tuning(3, "Drop-D", [38, 45, 50, 55, 59, 64]);
 m_arrInstruments[m_Guitar].Tunings[4] =  new Tuning(4, "Double-D", [38, 45, 50, 55, 59, 62]);
 m_arrInstruments[m_Guitar].Tunings[5] =  new Tuning(5, "D-Suspended (Modal)", [38, 45, 50, 55, 57, 62]);
 m_arrInstruments[m_Guitar].Tunings[6] =  new Tuning(6, "Open-D (Fingerstyle)", [38, 45, 50, 54, 57, 62]);
 m_arrInstruments[m_Guitar].Tunings[7] =  new Tuning(7, "Open-C (Fingerstyle)", [36, 43, 48, 55, 60, 64]);
 m_arrInstruments[m_Guitar].Tunings[8] =  new Tuning(8, "Open-G (Slide)", [38, 43, 50, 55, 59, 62]);
 m_arrInstruments[m_Guitar].Tunings[9] =  new Tuning(9, "Open-E (Blues)", [40, 47, 52, 56, 59, 64]);
 m_arrInstruments[m_Guitar].Tunings[10] = new Tuning(10,"Open-D (Minor)", [38, 45, 50, 53, 57, 62]);
 m_arrInstruments[m_Guitar].Tunings[11] = new Tuning(11,"Open-G (Minor)", [38, 43, 50, 55, 58, 62]);

 m_arrInstruments[m_Bass] = new Instrument(m_Bass, "Bass Guitar", 4, 24);
 m_arrInstruments[m_Bass].Tunings[0] =  new Tuning(0, "Standard Tuning", [28, 33, 38, 43]);  // E1 A1 D2 G2
 m_arrInstruments[m_Bass].Tunings[1] =  new Tuning(1, "Half-Step Down", [27, 32, 37, 42]);
 m_arrInstruments[m_Bass].Tunings[2] =  new Tuning(2, "Full-Step Down", [26, 31, 36, 41]);
 m_arrInstruments[m_Bass].Tunings[3] =  new Tuning(3, "Fifths (Extended Range)", [24, 31, 38, 45]);
 m_arrInstruments[m_Bass].Tunings[4] =  new Tuning(4, "Drop-D", [26, 33, 38, 43]);
 m_arrInstruments[m_Bass].Tunings[5] =  new Tuning(5, "Drop-C", [24, 33, 38, 43]);
 m_arrInstruments[m_Bass].Tunings[6] =  new Tuning(6, "Big Bottom", [24, 31, 36, 41]);
 m_arrInstruments[m_Bass].Tunings[7] =  new Tuning(7, "Drop-B", [23, 30, 35, 40]);
 m_arrInstruments[m_Bass].Tunings[1] =  new Tuning(8, "Low-B", [23, 28, 33, 38]);

 m_arrInstruments[m_Mandolin] = new Instrument(m_Mandolin, "Mandolin", 4, 17);
 m_arrInstruments[m_Mandolin].Tunings[0] =  new Tuning(0, "Standard Tuning", [55, 62, 69, 76]); // G3  D4  A4  E5
 m_arrInstruments[m_Mandolin].Tunings[1] =  new Tuning(1, "Half-Step Down", [54, 61, 68, 75]);  // Gb Db Ab Eb
 m_arrInstruments[m_Mandolin].Tunings[2] =  new Tuning(2, "Full-Step Down", [53, 60, 67, 74]);  // F  C  G  D
 m_arrInstruments[m_Mandolin].Tunings[3] =  new Tuning(3, "Drop-D", [55, 62, 69, 74]);          // G  D  A  D
 m_arrInstruments[m_Mandolin].Tunings[4] =  new Tuning(4, "D (Modal)", [62, 67, 69, 74]);       // G  D  A  D
 m_arrInstruments[m_Mandolin].Tunings[5] =  new Tuning(5, "Fourths", [50, 55, 60, 65]);         // D  G  C  F 
 m_arrInstruments[m_Mandolin].Tunings[6] =  new Tuning(6, "Open-D", [57, 62, 66, 74]);          // A  D  Gb D
 m_arrInstruments[m_Mandolin].Tunings[7] =  new Tuning(7, "Open-E", [56, 64, 67, 76]);          // G# E  B  E        
 m_arrInstruments[m_Mandolin].Tunings[8] =  new Tuning(8, "Open-G", [55, 62, 71, 74]);          // G  D  B  D  

 m_arrInstruments[m_Ukulele] = new Instrument(m_Ukulele, "Ukulele", 4, 20);
 m_arrInstruments[m_Ukulele].Tunings[0] =  new Tuning(0, "Standard Tuning", [67, 60, 64, 69]); // G4-C4-E4-A4

 m_arrInstruments[m_Keyboard] = new Instrument(m_Keyboard, "Keyboard", 24, 1);

 var piano = [];
 for (i=0;i<m_arrInstruments[m_Keyboard].Frets; i++)
   piano.push(60 + i); // C4

 m_arrInstruments[m_Keyboard].Tunings[0] =  new Tuning("Keyboard", piano);
}


// make the chord patterns

function makeChordPatterns()
{
 m_arrChordPatterns[m_cpMajor]  = new ChordPattern(m_cpMajor,   "Major",       symMajor,      [0,4,7], ["R", symMajor + "3", "P5"]);
 m_arrChordPatterns[m_cpMinor]  = new ChordPattern(m_cpMinor,   "Minor",       "m",           [0,3,7], ["R", "m3", "P5"]);
 m_arrChordPatterns[m_cpSus2]    = new ChordPattern(m_cpSus2,     "Sus2",      "sus2",        [0,2,7], ["R", symMajor + "2", "P5"]);
 m_arrChordPatterns[m_cpSus]    = new ChordPattern(m_cpSus,     "Sus4",        "sus4",        [0,5,7], ["R", "P4", "P5"]);
 m_arrChordPatterns[m_cpAug]    = new ChordPattern(m_cpAug,     "Aug+",         "+",          [0,4,8], ["R", symMajor + "3", "A5"]);
 m_arrChordPatterns[m_cpDim]    = new ChordPattern(m_cpDim,     "Dim",          symFDim,      [0,3,6], ["R", "m3",  symFlat + "5"]);
 m_arrChordPatterns[m_cpMajor6] = new ChordPattern(m_cpMajor6,  "Major 6th",    symMajor+"6", [0,4,7,9], ["R", symMajor + "3", "P5", symMajor + "6"]); // 1-3-5-6
 m_arrChordPatterns[m_cpMinor6] = new ChordPattern(m_cpMinor6,  "Minor 6th",    "m6",         [0,3,7,9], ["R", "m3", "P5", symMajor + "6"]); // 1-b3-5-6
 m_arrChordPatterns[m_cpMajor7] = new ChordPattern(m_cpMajor7,  "Major 7th",    symMajor+"7", [0,4,7,11], ["R", symMajor + "3", "P5", symMajor + "7"]); 
 m_arrChordPatterns[m_cpMinor7] = new ChordPattern(m_cpMinor7,  "Minor 7th",    "m7",         [0,3,7,10], ["R", "m3", "P5", "m7"]); // oops, thought it was 11
 m_arrChordPatterns[m_cpDom7]   = new ChordPattern(m_cpDom7,    "Dom 7th",      "7",          [0,4,7,10], ["R", symMajor + "3", "P5", "m7"]);
 m_arrChordPatterns[m_cpHalfDim7]  = new ChordPattern(m_cpHalfDim7,"Half Dim 7th", symDim7+"7", [0,3,6,10], ["R", "m3", "d5", "m7"]);
 m_arrChordPatterns[m_cpDim7]   = new ChordPattern(m_cpDim7,    "Dim 7th",      symFDim+"7",  [0,3,6,9], ["R", "m3", "d5", "d7"]);
 m_arrChordPatterns[m_cpMajor9] = new ChordPattern(m_cpMajor9,  "Major 9th",    symMajor+"9", [0,4,7,11,14], ["R", symMajor + "3", "P5", symMajor + "7", symMajor + "9"]);
 m_arrChordPatterns[m_cpMinor9] = new ChordPattern(m_cpMinor9,  "Minor 9th",    "m9",         [0,3,7,10,14], ["R", "m3", "P5", "m7", symMajor + "9"]);
 m_arrChordPatterns[m_cpDom9]   = new ChordPattern(m_cpDom9,    "Dom 9th",      "9",          [0,4,7,10,14], ["R", symMajor + "3", "P5", "m7", symMajor + "9"]);
}

// make all the midi notes, using the "Roland" naming standard
// MidiNote arguments are id #, midi note #, "C" offset, the octave, frequency in hertz
// requires that makeNotes is called first

// 0   1   2   3   4   5   6   7   8   9   10   11
// C   C#  D   D#  E   F   F#  G  G#   A   A#   B

function makeMidiNotes() // why isn't id the midi note number?  why have id at all?
{
 var i,k;

 m_arrMidiNotesHL[0] = new  MidiNote(0, 127,	7, 9, 12543.85);  // G9
 m_arrMidiNotesHL[1] = new MidiNote(1, 126, 6, 9, 11839.82);    // F#9
 m_arrMidiNotesHL[2] = new MidiNote(2, 125, 5, 9,	11175.30);    
 m_arrMidiNotesHL[3] = new MidiNote(3, 124, 4, 9, 10548.08);
 m_arrMidiNotesHL[4] = new MidiNote(4, 123, 3, 9, 9956.06);
 m_arrMidiNotesHL[5] = new MidiNote(5, 122, 2, 9,	9397.27);
 m_arrMidiNotesHL[6] = new MidiNote(6, 121, 1, 9, 8869.84);
 m_arrMidiNotesHL[7] = new MidiNote(7, 120, 0, 9, 8372.02);
 m_arrMidiNotesHL[8] = new MidiNote(8, 119, 11, 8, 7902.13);
 m_arrMidiNotesHL[9] = new MidiNote(9, 118, 10, 8, 7458.62);
 m_arrMidiNotesHL[10] = new MidiNote(10, 117, 9, 8,7040.00);
 m_arrMidiNotesHL[11] = new MidiNote(11, 116, 8, 8, 6644.88);
 m_arrMidiNotesHL[12] = new MidiNote(12, 115, 7, 8,	6271.93);
 m_arrMidiNotesHL[13] = new MidiNote(13, 114, 6, 8,	5919.91);
 m_arrMidiNotesHL[14] = new MidiNote(14, 113, 5, 8,	5587.65);
 m_arrMidiNotesHL[15] = new MidiNote(15, 112, 4, 8,	5274.04);
 m_arrMidiNotesHL[16] = new MidiNote(16, 111, 3, 8,	4978.03);
 m_arrMidiNotesHL[17] = new MidiNote(17, 110, 2, 8,	4698.64);
 m_arrMidiNotesHL[18] = new MidiNote(18, 109, 1, 8,	4434.92);
 m_arrMidiNotesHL[19] = new MidiNote(19, 108, 0, 8,	4186.01);
 m_arrMidiNotesHL[20] = new MidiNote(20, 107, 11, 7, 3951.07);
 m_arrMidiNotesHL[21] = new MidiNote(21, 106, 10, 7, 3729.31);
 m_arrMidiNotesHL[22] = new MidiNote(22, 105, 9, 7, 3520.00);
 m_arrMidiNotesHL[23] = new MidiNote(23, 104, 8, 7, 3322.44);
 m_arrMidiNotesHL[24] = new MidiNote(24, 103, 7, 7,	3135.96);
 m_arrMidiNotesHL[25] = new MidiNote(25, 102, 6, 7,	2959.96);
 m_arrMidiNotesHL[26] = new MidiNote(26, 101, 5, 7,	2793.83);
 m_arrMidiNotesHL[27] = new MidiNote(27, 100, 4, 7,	2637.02);
 m_arrMidiNotesHL[28] = new MidiNote(28, 99,	3, 7, 2489.02);
 m_arrMidiNotesHL[29] = new MidiNote(29, 98,	2, 7, 2349.32);
 m_arrMidiNotesHL[30] = new MidiNote(30, 97,	1, 7, 2217.46);
 m_arrMidiNotesHL[31] = new MidiNote(31, 96,	0, 7,	2093.00);
 m_arrMidiNotesHL[32] = new MidiNote(32, 95, 11, 6,	1975.53);
 m_arrMidiNotesHL[33] = new MidiNote(33, 94, 10, 6,	1864.66);
 m_arrMidiNotesHL[34] = new MidiNote(34, 93, 9, 6, 1760.00);
 m_arrMidiNotesHL[35] = new MidiNote(35, 92, 8, 6, 1661.22);
 m_arrMidiNotesHL[36] = new MidiNote(36, 91, 7, 6, 1567.98);
 m_arrMidiNotesHL[37] = new MidiNote(37, 90, 6, 6, 1479.98);
 m_arrMidiNotesHL[38] = new MidiNote(38, 89, 5, 6, 1396.91);
 m_arrMidiNotesHL[39] = new MidiNote(39, 88, 4, 6, 1318.51);
 m_arrMidiNotesHL[40] = new MidiNote(40, 87, 3, 6, 1244.51);
 m_arrMidiNotesHL[41] = new MidiNote(41, 86, 2, 6, 1174.66);
 m_arrMidiNotesHL[42] = new MidiNote(42, 85, 1, 6, 1108.73);
 m_arrMidiNotesHL[43] = new MidiNote(43, 84, 0,	6, 1046.50);
 m_arrMidiNotesHL[44] = new MidiNote(44, 83, 11, 5, 987.77);
 m_arrMidiNotesHL[45] = new MidiNote(45, 82, 10, 5,	932.33);
 m_arrMidiNotesHL[46] = new MidiNote(46, 81, 9, 5, 880.00);
 m_arrMidiNotesHL[47] = new MidiNote(47, 80, 8, 5, 830.61);
 m_arrMidiNotesHL[48] = new MidiNote(48, 79, 7, 5, 783.99);
 m_arrMidiNotesHL[49] = new MidiNote(49, 78, 6, 5, 739.99);
 m_arrMidiNotesHL[50] = new MidiNote(50, 77, 5, 5, 698.46);
 m_arrMidiNotesHL[51] = new MidiNote(51, 76, 4, 5, 659.26);
 m_arrMidiNotesHL[52] = new MidiNote(52, 75, 3, 5, 622.25);
 m_arrMidiNotesHL[53] = new MidiNote(53, 74, 2, 5, 587.33);
 m_arrMidiNotesHL[54] = new MidiNote(54, 73, 1, 5, 554.37);
 m_arrMidiNotesHL[55] = new MidiNote(55, 72, 0, 5, 523.25);
 m_arrMidiNotesHL[56] = new MidiNote(56, 71, 11, 4, 493.88);
 m_arrMidiNotesHL[57] = new MidiNote(57, 70, 10, 4, 466.16);
 m_arrMidiNotesHL[58] = new MidiNote(58, 69, 9, 4, 440.00);  // A4
 m_arrMidiNotesHL[59] = new MidiNote(59, 68, 8, 4, 415.30);
 m_arrMidiNotesHL[60] = new MidiNote(60, 67, 7, 4, 392.00);  // G4
 m_arrMidiNotesHL[61] = new MidiNote(61, 66, 6, 4, 369.99);
 m_arrMidiNotesHL[62] = new MidiNote(62, 65, 5, 4, 349.23);
 m_arrMidiNotesHL[63] = new MidiNote(63, 64, 4, 4, 329.63);  // E4
 m_arrMidiNotesHL[64] = new MidiNote(64, 63, 3, 4, 311.13);
 m_arrMidiNotesHL[65] = new MidiNote(65, 62, 2, 4, 293.66);
 m_arrMidiNotesHL[66] = new MidiNote(66, 61, 1, 4, 277.18);
 m_arrMidiNotesHL[67] = new MidiNote(67, 60, 0, 4, 261.63);   // middle C4
 m_arrMidiNotesHL[68] = new MidiNote(68, 59, 11, 3, 246.94);
 m_arrMidiNotesHL[69] = new MidiNote(69, 58, 10, 3, 233.08);
 m_arrMidiNotesHL[70] = new MidiNote(70, 57, 9, 3, 220.00);
 m_arrMidiNotesHL[71] = new MidiNote(71, 56, 8, 3, 207.65);
 m_arrMidiNotesHL[72] = new MidiNote(72, 55, 7, 3, 196.00);
 m_arrMidiNotesHL[73] = new MidiNote(73, 54, 6, 3, 185.00);
 m_arrMidiNotesHL[74] = new MidiNote(74, 53, 5, 3, 174.61);
 m_arrMidiNotesHL[75] = new MidiNote(75, 52, 4, 3, 164.81);
 m_arrMidiNotesHL[76] = new MidiNote(76, 51, 3, 3, 155.56);
 m_arrMidiNotesHL[77] = new MidiNote(77, 50, 2, 3, 146.83);
 m_arrMidiNotesHL[78] = new MidiNote(78, 49, 1, 3, 138.59);
 m_arrMidiNotesHL[79] = new MidiNote(79, 48, 0, 3, 130.81);
 m_arrMidiNotesHL[80] = new MidiNote(80, 47, 11, 2, 123.47);
 m_arrMidiNotesHL[81] = new MidiNote(81, 46, 10, 2, 116.54);
 m_arrMidiNotesHL[82] = new MidiNote(82, 45, 9, 2, 110.00);
 m_arrMidiNotesHL[83] = new MidiNote(83, 44, 8, 2, 103.83);
 m_arrMidiNotesHL[84] = new MidiNote(84, 43, 7, 2, 98.00);
 m_arrMidiNotesHL[85] = new MidiNote(85, 42, 6, 2, 92.50);
 m_arrMidiNotesHL[86] = new MidiNote(86, 41, 5, 2, 87.31);
 m_arrMidiNotesHL[87] = new MidiNote(87, 40, 4, 2, 82.41);
 m_arrMidiNotesHL[88] = new MidiNote(88, 39, 3, 2, 77.78);
 m_arrMidiNotesHL[89] = new MidiNote(89, 38, 2, 2, 73.42);
 m_arrMidiNotesHL[90] = new MidiNote(90, 37, 1, 2, 69.30);
 m_arrMidiNotesHL[91] = new MidiNote(91, 36, 0, 2, 65.41);
 m_arrMidiNotesHL[92] = new MidiNote(92, 35, 11, 1, 61.74);
 m_arrMidiNotesHL[93] = new MidiNote(93, 34, 10, 1, 58.27);
 m_arrMidiNotesHL[94] = new MidiNote(94, 33, 9, 1, 55.00);
 m_arrMidiNotesHL[95] = new MidiNote(95, 32, 8, 1, 51.91);
 m_arrMidiNotesHL[96] = new MidiNote(96, 31, 7, 1, 49.00);
 m_arrMidiNotesHL[97] = new MidiNote(97, 30, 6, 1, 46.25);
 m_arrMidiNotesHL[98] = new MidiNote(98, 29, 5, 1, 43.65);
 m_arrMidiNotesHL[99] = new MidiNote(99, 28, 4, 1, 41.20);
 m_arrMidiNotesHL[100] = new MidiNote(100, 27, 3, 1, 38.89);
 m_arrMidiNotesHL[101] = new MidiNote(101, 26, 2, 1, 36.71);
 m_arrMidiNotesHL[102] = new MidiNote(102, 25, 1, 1, 34.65);
 m_arrMidiNotesHL[103] = new MidiNote(103, 24, 0, 1, 32.70);
 m_arrMidiNotesHL[104] = new MidiNote(104, 23, 11, 0, 30.87);
 m_arrMidiNotesHL[105] = new MidiNote(105, 22, 10, 0, 29.14);
 m_arrMidiNotesHL[106] = new MidiNote(106, 21, 9, 0, 27.50);

 // copy notes to LH array in reverse order

 k = 106;
 for (i = 0; i<107; i++)
  {
   m_arrMidiNotesLH[i] = m_arrMidiNotesHL[k];
   m_mapMidiNotes.set(m_arrMidiNotesHL[k].Number, m_arrMidiNotesHL[k]); // this map is used to look up the Midi object given a midi note number
   k--;
  }
}

// C C#/Db D D#/Eb E  F  F#/Gb G G#/Ab A A#/Bb B/Cb
// 0   1   2   3   4  5    6   7   8   9  10    11

// Modes

function makeModes()
{
 m_arrMajorKeys = [new Note(0,"C",""),new Note(7,"G",""),new Note(2,"D",""),new Note(9,"A",""),new Note(4,"E",""),new Note(11, "B",""),new Note(6,"F","#"),new Note(1,"C","#"),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b"),new Note(1,"D","b"),new Note(6,"G","b"),new Note(11,"C","b")];
 m_arrMinorKeys = [new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")];

 m_arrModes[0]=new Mode(0,"#7BBDFF","Ionian (Major)",[2,2,1,2,2,2,1],[m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim], m_arrMajorKeys);
 
 m_arrModes[1]=new Mode(1,"#7BBDFF","Dorian",[2,1,2,2,2,1,2],[m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor], m_arrMinorKeys);
 m_arrModes[2]=new Mode(2,"#7BBDFF","Phrygian",[1,2,2,2,1,2,2],[m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor], m_arrMinorKeys);
 m_arrModes[3]=new Mode(3,"#7BBDFF","Lydian",[2,2,2,1,2,2,1], [m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor],m_arrMajorKeys);
 m_arrModes[4]=new Mode(4,"#7BBDFF","Mixolydian",[2,2,1,2,2,1,2], [m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor],m_arrMajorKeys);
 m_arrModes[5]=new Mode(5,"#7BBDFF","Aeolian (Minor)",[2,1,2,2,1,2,2], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],m_arrMinorKeys);
 m_arrModes[6]=new Mode(6,"#7BBDFF","Locrian",[1,2,2,1,2,2,2], [m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor], m_arrMinorKeys);

 m_arrModes[7]=new Mode(7,"#7BFFBD","Major 7th",[2,2,1,2,2,2,1], [m_cpMajor7,m_cpMinor7,m_cpMinor7,m_cpMajor7,m_cpDom7,m_cpMinor7,m_cpHalfDim7],m_arrMajorKeys);
 m_arrModes[8]=new Mode(8,"#7BFFBD","Minor 7th",[2,1,2,2,1,2,2], [m_cpMinor7,m_cpHalfDim7,m_cpMajor7,m_cpMinor7,m_cpMinor7,m_cpMajor7,m_cpDom7],m_arrMinorKeys);

 // m_arrModes[9]=new Mode(9,"#FFFF7B","Harmonic Major",[2,2,1,2,2,3,1], [m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim],m_arrMajorKeys);
 m_arrModes[9]=new Mode(9,"#FFFF7B","Harmonic Minor",[2,1,2,2,1,3,1], [m_cpMinor,m_cpDim,m_cpAug,m_cpMinor,m_cpMajor,m_cpMajor,m_cpDim],m_arrMinorKeys);
 m_arrModes[10]=new Mode(10,"#FFFF7B","Melodic Minor (ascending)",[2,1,2,2,2,2,1], [m_cpMinor,m_cpMinor,m_cpAug,m_cpMajor,m_cpMajor,m_cpDim,m_cpDim],m_arrMinorKeys);
 m_arrModes[11]=new Mode(11,"#FFFF7B","Gypsy Minor",[2,1,3,1,1,2,2], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],m_arrMinorKeys);
 // m_arrModes[13]=new Mode(13,"#FFFF7B","Hungarian Minor",[2,1,3,1,1,3,1], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],m_arrMinorKeys);
 m_arrModes[12]=new Mode(12,"#FFFF7B","Persian Minor",[1,3,1,1,2,3,1], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],m_arrMinorKeys);
 m_arrModes[13]=new Mode(13,"#FFFF7B","Spanish Minor",[1,3,1,2,1,2,2], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],m_arrMinorKeys);

 m_arrModes[14]=new Mode(14,"#FFB8FF","Altered Dominant",[1,2,1,2,2,2,2], [m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor], m_arrMajorKeys);
 m_arrModes[15]=new Mode(15,"#FFB8FF","Overtone Dominant",[2,2,2,1,2,1,2], [m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor],m_arrMajorKeys);
 // m_arrModes[18]=new Mode(18,"#FFB8FF","Augmented Whole Tone",[2,2,2,2,2,2,2], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],m_arrMinorKeys);
}

 // c mjr  C D E F G A B C

 // blues  C  D  Eb  E  G  A   C major
 //        0  2  3   4  7  9   12
 // stpes  0  2  1   1  3  2   3
 // letter    1  1   0  2  1   2    blues letter increments
 // 1, 2,♭3, 3, 5, 6

 // raised 2nd

 // minor 1-b3-4-b5-5-b7
 // blues C  Eb F   Gb G  Bb  C minor
 //       0  3  5   6  7  10  12
 //       0  3  2   1  1  3   2
 //       1, ♭3, 4, ♭5, 5, ♭7
 //     

function makeScales()
{
 m_arrScales[0] = new Scale(1, "#7BBDFF", "Blues Major", [2, 1, 1, 3, 2, 3], [null, null, [1,1], null, null, null]);            // raise the 2nd rather than flat the 3rd
 m_arrScales[1] = new Scale(2, "#7BBDFF", "Blues Minor", [3, 2, 1, 1, 3, 2], [null, [1,1], null, [3,1], null, [5,1]]);          // raise 2nd, 3th & 6th

}

// C C#/Db D D#/Eb E  F  F#/Gb G G#/Ab A A#/Bb B/Cb
// 0   1   2   3   4  5    6   7   8   9  10    11

// makeChordPatternPlacements generated by GuitarChord program at 3/31/2023 6:16:47 PM

function makeChordPatternPlacements()
{
 m_arrChordPatterns[m_cpMajor].PatternGuitar[0] = new Placement(1, m_Guitar, 0, [new Fingering(4, 1)], [new Fingering(2, 2)], [new Fingering(1, 3)], [], [new Fingering(3, 0), new Fingering(5, 0)], [new Fingering(0, 0)]);
 m_arrChordPatterns[m_cpMajor].PatternGuitar[1] = new Placement(2, m_Guitar, 2, [new Fingering(3, 2)], [new Fingering(5, 2)], [new Fingering(4, 3)], [], [new Fingering(2, 0)], [new Fingering(0, 0), new Fingering(1, 0)]);
 m_arrChordPatterns[m_cpMajor].PatternGuitar[2] = new Placement(3, m_Guitar, 4, [], [new Fingering(3, 1)], [new Fingering(1, 2)], [new Fingering(2, 2)], [new Fingering(0, 0), new Fingering(4, 0), new Fingering(5, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternGuitar[3] = new Placement(4, m_Guitar, 7, [new Fingering(1, 2)], [new Fingering(0, 3)], [new Fingering(5, 3)], [], [new Fingering(2, 0), new Fingering(3, 0), new Fingering(4, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternGuitar[4] = new Placement(5, m_Guitar, 9, [new Fingering(4, 2)], [new Fingering(3, 2)], [new Fingering(2, 2)], [], [new Fingering(1, 0), new Fingering(5, 0)], [new Fingering(0, 0)]);
 m_arrChordPatterns[m_cpMajor].PatternMandolin[0] = new Placement(6, m_Mandolin, 7, [new Fingering(2, 2)], [new Fingering(3, 3)], [], [], [new Fingering(0, 0), new Fingering(1, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternMandolin[1] = new Placement(7, m_Mandolin, 0, [new Fingering(1, 2)], [new Fingering(2, 3)], [], [], [new Fingering(0, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternMandolin[2] = new Placement(8, m_Mandolin, 2, [new Fingering(0, 2)], [new Fingering(3, 2)], [], [], [new Fingering(1, 0), new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternMandolin[3] = new Placement(9, m_Mandolin, 5, [new Fingering(3, 1)], [new Fingering(1, 3)], [new Fingering(0, 5)], [], [new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternMandolin[4] = new Placement(10, m_Mandolin, 4, [new Fingering(1, 2), new Fingering(2, 2)], [], [], [new Fingering(3, 4)], [], [new Fingering(0, 0)]);
 m_arrChordPatterns[m_cpMajor].PatternMandolin[5] = new Placement(11, m_Mandolin, 9, [new Fingering(0, 2), new Fingering(1, 2)], [], [], [], [new Fingering(2, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternMandolin[6] = new Placement(12, m_Mandolin, 11, [new Fingering(1, 1)], [new Fingering(2, 2)], [new Fingering(3, 2)], [new Fingering(0, 4)], [], []);
 m_arrChordPatterns[m_cpMajor].PatternUkulele[0] = new Placement(13, m_Ukulele, 0, [], [], [new Fingering(3, 3)], [], [new Fingering(0, 0), new Fingering(1, 0), new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternUkulele[1] = new Placement(14, m_Ukulele, 5, [new Fingering(2, 1)], [new Fingering(0, 2)], [], [], [new Fingering(1, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternUkulele[2] = new Placement(15, m_Ukulele, 7, [new Fingering(1, 2)], [new Fingering(3, 2)], [new Fingering(2, 3)], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternUkulele[3] = new Placement(16, m_Ukulele, 9, [new Fingering(1, 1)], [new Fingering(0, 2)], [], [], [new Fingering(2, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternUkulele[4] = new Placement(17, m_Ukulele, 2, [new Fingering(0, 2)], [new Fingering(1, 2)], [new Fingering(2, 2)], [], [new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMajor].PatternUkulele[5] = new Placement(18, m_Ukulele, 4, [new Fingering(0, 1)], [new Fingering(3, 2)], [], [new Fingering(1, 4)], [new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternGuitar[0] = new Placement(19, m_Guitar, 9, [new Fingering(4, 1)], [new Fingering(2, 2)], [new Fingering(3, 2)], [], [new Fingering(1, 0), new Fingering(5, 0)], [new Fingering(0, 0)]);
 m_arrChordPatterns[m_cpMinor].PatternGuitar[1] = new Placement(20, m_Guitar, 2, [new Fingering(5, 1)], [new Fingering(3, 2)], [new Fingering(4, 3)], [], [new Fingering(2, 0)], [new Fingering(0, 0), new Fingering(1, 0)]);
 m_arrChordPatterns[m_cpMinor].PatternGuitar[2] = new Placement(21, m_Guitar, 4, [new Fingering(1, 2)], [new Fingering(2, 2)], [], [], [new Fingering(0, 0), new Fingering(3, 0), new Fingering(4, 0), new Fingering(5, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternMandolin[0] = new Placement(22, m_Mandolin, 9, [new Fingering(0, 2)], [new Fingering(1, 2)], [new Fingering(2, 3)], [], [new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternMandolin[1] = new Placement(23, m_Mandolin, 4, [], [new Fingering(1, 2)], [new Fingering(2, 2)], [], [new Fingering(0, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternMandolin[2] = new Placement(24, m_Mandolin, 11, [new Fingering(2, 2), new Fingering(3, 2)], [], [new Fingering(0, 4)], [], [new Fingering(1, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternMandolin[3] = new Placement(25, m_Mandolin, 7, [], [], [new Fingering(2, 1)], [new Fingering(3, 3)], [new Fingering(0, 0), new Fingering(1, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternMandolin[4] = new Placement(26, m_Mandolin, 2, [new Fingering(3, 1)], [new Fingering(0, 2)], [], [], [new Fingering(1, 0), new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternUkulele[0] = new Placement(27, m_Ukulele, 9, [], [new Fingering(0, 2)], [], [], [new Fingering(1, 0), new Fingering(2, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternUkulele[1] = new Placement(28, m_Ukulele, 0, [new Fingering(1, 3), new Fingering(2, 3), new Fingering(3, 3)], [], [], [], [], []);
 m_arrChordPatterns[m_cpMinor].PatternUkulele[2] = new Placement(29, m_Ukulele, 2, [new Fingering(2, 1)], [new Fingering(0, 2)], [new Fingering(1, 2)], [], [new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternUkulele[3] = new Placement(30, m_Ukulele, 4, [new Fingering(3, 2)], [new Fingering(2, 3)], [new Fingering(1, 4)], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternUkulele[4] = new Placement(31, m_Ukulele, 5, [new Fingering(0, 1)], [new Fingering(2, 1)], [], [new Fingering(3, 3)], [new Fingering(1, 0)], []);
 m_arrChordPatterns[m_cpMinor].PatternUkulele[5] = new Placement(32, m_Ukulele, 7, [new Fingering(3, 1)], [new Fingering(1, 2)], [new Fingering(2, 3)], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpSus2].PatternGuitar[0] = new Placement(33, m_Guitar, 4, [], [new Fingering(1, 2)], [new Fingering(2, 2)], [new Fingering(3, 2)], [new Fingering(0, 0), new Fingering(4, 0), new Fingering(5, 0)], []);
 m_arrChordPatterns[m_cpSus2].PatternUkulele[0] = new Placement(34, m_Ukulele, 0, [new Fingering(1, 2)], [new Fingering(2, 3)], [new Fingering(3, 3)], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpSus2].PatternUkulele[1] = new Placement(35, m_Ukulele, 2, [], [new Fingering(0, 2)], [new Fingering(1, 2)], [], [new Fingering(2, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpSus2].PatternUkulele[2] = new Placement(36, m_Ukulele, 7, [], [new Fingering(1, 2)], [new Fingering(2, 3)], [], [new Fingering(0, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpSus].PatternUkulele[0] = new Placement(37, m_Ukulele, 9, [], [new Fingering(0, 2)], [new Fingering(1, 2)], [], [new Fingering(2, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpSus].PatternUkulele[1] = new Placement(38, m_Ukulele, 0, [new Fingering(2, 1)], [], [new Fingering(3, 3)], [], [new Fingering(0, 0), new Fingering(1, 0)], []);
 m_arrChordPatterns[m_cpSus].PatternUkulele[2] = new Placement(39, m_Ukulele, 2, [], [new Fingering(1, 2)], [new Fingering(2, 3)], [], [new Fingering(0, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpSus].PatternUkulele[3] = new Placement(40, m_Ukulele, 7, [new Fingering(1, 2)], [new Fingering(2, 3)], [new Fingering(3, 3)], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpAug].PatternGuitar[0] = new Placement(41, m_Guitar, 9, [new Fingering(2, 1)], [new Fingering(3, 2)], [new Fingering(4, 1)], [], [new Fingering(1, 0)], [new Fingering(0, 0), new Fingering(5, 0)]);
 m_arrChordPatterns[m_cpAug].PatternGuitar[1] = new Placement(42, m_Guitar, 4, [new Fingering(2, 2)], [new Fingering(4, 2)], [new Fingering(3, 3)], [new Fingering(5, 3)], [], [new Fingering(0, 0), new Fingering(1, 0)]);
 m_arrChordPatterns[m_cpAug].PatternUkulele[0] = new Placement(43, m_Ukulele, 0, [new Fingering(0, 1)], [], [new Fingering(3, 3)], [], [new Fingering(1, 0), new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpAug].PatternUkulele[1] = new Placement(44, m_Ukulele, 2, [new Fingering(3, 1)], [new Fingering(1, 2)], [new Fingering(2, 2)], [new Fingering(0, 3)], [], []);
 m_arrChordPatterns[m_cpAug].PatternUkulele[2] = new Placement(45, m_Ukulele, 7, [new Fingering(3, 2)], [new Fingering(1, 3)], [new Fingering(2, 3)], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpDim].PatternUkulele[0] = new Placement(46, m_Ukulele, 11, [new Fingering(2, 1)], [new Fingering(1, 2)], [new Fingering(3, 2)], [new Fingering(0, 4)], [], []);
 m_arrChordPatterns[m_cpDim].PatternUkulele[1] = new Placement(47, m_Ukulele, 0, [new Fingering(2, 2)], [new Fingering(1, 3)], [new Fingering(3, 3)], [], [], [new Fingering(0, 0)]);
 m_arrChordPatterns[m_cpDim].PatternUkulele[2] = new Placement(48, m_Ukulele, 2, [new Fingering(0, 1)], [new Fingering(2, 1)], [new Fingering(1, 2)], [], [], [new Fingering(3, 0)]);
 m_arrChordPatterns[m_cpDim].PatternUkulele[3] = new Placement(49, m_Ukulele, 4, [new Fingering(3, 1)], [], [], [new Fingering(1, 4)], [new Fingering(0, 0), new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpDim].PatternUkulele[4] = new Placement(50, m_Ukulele, 7, [new Fingering(1, 1)], [new Fingering(3, 1)], [new Fingering(2, 3)], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpMajor6].PatternUkulele[0] = new Placement(51, m_Ukulele, 7, [], [new Fingering(1, 2)], [new Fingering(3, 2)], [], [new Fingering(0, 0), new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpMinor6].PatternGuitar[0] = new Placement(52, m_Guitar, 9, [new Fingering(2, 2)], [new Fingering(3, 1)], [new Fingering(4, 2)], [], [new Fingering(1, 0), new Fingering(5, 0)], [new Fingering(0, 0)]);
 m_arrChordPatterns[m_cpMinor6].PatternGuitar[1] = new Placement(53, m_Guitar, 4, [new Fingering(2, 1)], [new Fingering(3, 1)], [new Fingering(1, 2)], [], [new Fingering(0, 0), new Fingering(4, 0), new Fingering(5, 0)], []);
 m_arrChordPatterns[m_cpMinor6].PatternUkulele[0] = new Placement(54, m_Ukulele, 7, [new Fingering(3, 1)], [new Fingering(1, 2)], [], [], [new Fingering(0, 0), new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpMajor7].PatternUkulele[0] = new Placement(55, m_Ukulele, 9, [new Fingering(0, 1)], [new Fingering(1, 1)], [], [], [new Fingering(2, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMajor7].PatternUkulele[1] = new Placement(56, m_Ukulele, 0, [], [new Fingering(3, 2)], [], [], [new Fingering(0, 0), new Fingering(1, 0), new Fingering(2, 0)], []);
 m_arrChordPatterns[m_cpMajor7].PatternUkulele[2] = new Placement(57, m_Ukulele, 7, [new Fingering(1, 2), new Fingering(2, 2), new Fingering(3, 2)], [], [], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpMinor7].PatternGuitar[0] = new Placement(58, m_Guitar, 4, [new Fingering(3, 1)], [new Fingering(1, 2)], [], [], [new Fingering(0, 0), new Fingering(2, 0), new Fingering(4, 0), new Fingering(5, 0)], []);
 m_arrChordPatterns[m_cpMinor7].PatternGuitar[1] = new Placement(59, m_Guitar, 9, [new Fingering(4, 1)], [new Fingering(2, 2)], [], [], [new Fingering(1, 0), new Fingering(3, 0), new Fingering(5, 0)], [new Fingering(0, 0)]);
 m_arrChordPatterns[m_cpMinor7].PatternUkulele[0] = new Placement(60, m_Ukulele, 9, [], [], [], [], [new Fingering(0, 0), new Fingering(1, 0), new Fingering(2, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpMinor7].PatternUkulele[1] = new Placement(61, m_Ukulele, 7, [new Fingering(2, 1), new Fingering(3, 1)], [new Fingering(1, 2)], [], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpDom7].PatternUkulele[0] = new Placement(62, m_Ukulele, 9, [new Fingering(1, 1)], [], [], [], [new Fingering(0, 0), new Fingering(2, 0), new Fingering(3, 0)], []);
 m_arrChordPatterns[m_cpDom7].PatternUkulele[1] = new Placement(63, m_Ukulele, 7, [new Fingering(2, 1)], [new Fingering(1, 2)], [new Fingering(3, 2)], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpHalfDim7].PatternUkulele[0] = new Placement(64, m_Ukulele, 7, [new Fingering(1, 1), new Fingering(2, 1), new Fingering(3, 1)], [], [], [], [new Fingering(0, 0)], []);
 m_arrChordPatterns[m_cpDim7].PatternUkulele[0] = new Placement(65, m_Ukulele, 7, [], [new Fingering(3, 1)], [new Fingering(1, 1)], [], [new Fingering(0, 0), new Fingering(2, 0)], []);
}

function makeBarreChordPatterns()
{                                
 // E                                    //   index                                                                                                                                              // middle             // ring               // pinky         // no play          
 m_arrGuitarBarre[0] = new BarrePlacement(1, 4, m_cpMajor, m_Guitar, [new BarreIndex(0, 0, 1), new BarreIndex(1, 0, 0), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 0), new BarreIndex(4, 0, 1), new BarreIndex(5, 0, 1)], [new Fingering(3, 1)], [new Fingering(1, 2)], [new Fingering(2, 2)], []);
 m_arrGuitarBarre[1] = new BarrePlacement(2, 4, m_cpMinor, m_Guitar, [new BarreIndex(0, 0, 1), new BarreIndex(1, 0, 0), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 1), new BarreIndex(4, 0, 1), new BarreIndex(5, 0, 1)], [], [new Fingering(1, 2)], [new Fingering(2 ,2)], []);
 
// A                                                                     // low e is not root of chord on this barre so is shown as no play 
 m_arrGuitarBarre[2] = new BarrePlacement(3, 9, m_cpMajor, m_Guitar, [new BarreIndex(1, 0, 1), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 0), new BarreIndex(4, 0, 0), new BarreIndex(5, 0, 1)], [], [new Fingering(2, 2), new Fingering(3, 2), new Fingering(4, 2)], [], [new Fingering(0, 0)]);
 m_arrGuitarBarre[3] = new BarrePlacement(4, 9, m_cpMinor, m_Guitar, [new BarreIndex(1, 0, 1), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 0), new BarreIndex(4, 0, 0), new BarreIndex(5, 0, 1)], [new Fingering(4, 1)], [new Fingering(2, 2)], [new Fingering(3, 2)], [new Fingering(0, 0)]);
 m_arrGuitarBarre[4] = new BarrePlacement(5, 9, m_cpDom7, m_Guitar,  [new BarreIndex(1, 0, 1), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 0), new BarreIndex(4, 0, 0), new BarreIndex(5, 0, 1)], [], [new Fingering(2, 2)], [new Fingering(4, 2)], [new Fingering(0, 0)]);
 m_arrGuitarBarre[5] = new BarrePlacement(6, 9, m_cpMajor7, m_Guitar,[new BarreIndex(1, 0, 1), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 0), new BarreIndex(4, 0, 0), new BarreIndex(5, 0, 1)], [new Fingering(2,2)], [new Fingering(3, 1)], [new Fingering(4, 2)], [new Fingering(0, 0)]);
                                                                       // index                   // middle
 m_arrGuitarBarre[6] = new BarrePlacement(7, 9, m_cpDim, m_Guitar,   [new BarreIndex(1, 0, 1)], [new Fingering(2, 1)], [new Fingering(3, 2)], [new Fingering(4, 1)], [new Fingering(0, 0), new Fingering(5,0)]);
 
 // D                                                                       // index                                                                                        // middle     // ring                // pinky               // no play
 m_arrMandolinBarre[0] = new BarrePlacement(8, 2, m_cpMajor, m_Mandolin, [new BarreIndex(0,0,0), new BarreIndex(1,0,1), new BarreIndex(2,0,1), new BarreIndex(3,0,0)], [], [new Fingering(0, 2)], [new Fingering(3,2)], []);
 m_arrMandolinBarre[1] = new BarrePlacement(9, 2, m_cpMinor, m_Mandolin, [new BarreIndex(0,0,0), new BarreIndex(1,0,1), new BarreIndex(2,0,1), new BarreIndex(3,0,0)], [new Fingering(3,1)], [new Fingering(0, 2)], [], []);

 // C
 // m_arrUkuleleBarre[0] = new BarrePlacement(10, 0, m_cpMajor, m_Ukulele, [new BarreIndex(0,0,1), new BarreIndex(1,0,1), new BarreIndex(2,0,1), new BarreIndex(3,0,0)], [], [], new Fingering(3, 3), []);

 // A                                                                                                                                                                  middle                ring              pinky        no play
 m_arrUkuleleBarre[0] = new BarrePlacement(11, 9, m_cpMajor, m_Ukulele, [new BarreIndex(0,0,0), new BarreIndex(1,0,0), new BarreIndex(2,0,1), new BarreIndex(3,0,1)], [new Fingering(1, 1)], [new Fingering(0, 2)], [], []);
 m_arrUkuleleBarre[1] = new BarrePlacement(12, 9, m_cpMinor, m_Ukulele, [new BarreIndex(0,0,0), new BarreIndex(1,0,1), new BarreIndex(2,0,1), new BarreIndex(3,0,1)], [], [new Fingering(0, 2)], [], []);


}

function makeGuitar() // midi notes of guitar strings, 0 index is low E 
{
 var i;

 m_arrGuitar[0] = [];
 m_arrGuitar[1] = [];
 m_arrGuitar[2] = [];
 m_arrGuitar[3] = [];
 m_arrGuitar[4] = [];
 m_arrGuitar[5] = [];

 for (i=0; i<m_arrInstruments[m_Guitar].Frets; i++)
  {
   m_arrGuitar[0].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[0] + i);
   m_arrGuitar[1].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[1] + i);
   m_arrGuitar[2].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[2] + i);
   m_arrGuitar[3].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[3] + i);
   m_arrGuitar[4].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[4] + i);
   m_arrGuitar[5].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[5] + i);
  }
}

function makeBass() // midi notes of bass strings
{
 var i;

 m_arrBass[0] = [];
 m_arrBass[1] = [];
 m_arrBass[2] = [];
 m_arrBass[3] = [];

 for (i=0; i<m_arrInstruments[m_Bass].Frets; i++)
  {
   m_arrBass[0].push(m_arrInstruments[m_Bass].Tunings[m_CurrentBassTuning].TuningMidiNotes[0] + i);
   m_arrBass[1].push(m_arrInstruments[m_Bass].Tunings[m_CurrentBassTuning].TuningMidiNotes[1] + i);
   m_arrBass[2].push(m_arrInstruments[m_Bass].Tunings[m_CurrentBassTuning].TuningMidiNotes[2] + i);
   m_arrBass[3].push(m_arrInstruments[m_Bass].Tunings[m_CurrentBassTuning].TuningMidiNotes[3] + i);
  }
}

function makeMandolin() // midi notes of mandolin strings
{
 var i;

 m_arrMandolin[0] = [];
 m_arrMandolin[1] = [];
 m_arrMandolin[2] = [];
 m_arrMandolin[3] = [];

 for (i=0; i<m_arrInstruments[m_Mandolin].Frets; i++)
  {
   m_arrMandolin[0].push(m_arrInstruments[m_Mandolin].Tunings[m_CurrentMandolinTuning].TuningMidiNotes[0] + i);
   m_arrMandolin[1].push(m_arrInstruments[m_Mandolin].Tunings[m_CurrentMandolinTuning].TuningMidiNotes[1] + i);
   m_arrMandolin[2].push(m_arrInstruments[m_Mandolin].Tunings[m_CurrentMandolinTuning].TuningMidiNotes[2] + i);
   m_arrMandolin[3].push(m_arrInstruments[m_Mandolin].Tunings[m_CurrentMandolinTuning].TuningMidiNotes[3] + i);
  }
}

function makeUkulele() // midi notes of ukulele strings
{
 var i;

 m_arrUkulele[0] = [];
 m_arrUkulele[1] = [];
 m_arrUkulele[2] = [];
 m_arrUkulele[3] = [];

 for (i=0; i<m_arrInstruments[m_Ukulele].Frets; i++)
  {
   m_arrUkulele[0].push(m_arrInstruments[m_Ukulele].Tunings[m_CurrentUkuleleTuning].TuningMidiNotes[0] + i);
   m_arrUkulele[1].push(m_arrInstruments[m_Ukulele].Tunings[m_CurrentUkuleleTuning].TuningMidiNotes[1] + i);
   m_arrUkulele[2].push(m_arrInstruments[m_Ukulele].Tunings[m_CurrentUkuleleTuning].TuningMidiNotes[2] + i);
   m_arrUkulele[3].push(m_arrInstruments[m_Ukulele].Tunings[m_CurrentUkuleleTuning].TuningMidiNotes[3] + i);
  }
}

// Utility functions

function Quotes(text) // append double quotes to a string
{
 return "\"" + text + "\"";
}

function GetPlayNote(midiNum) // get a new PlayNote object from a midi note based on current m_Key
{
 var midi, note, text;
 
 midi = m_mapMidiNotes.get(midiNum);
 note = m_Key.OffsetNote(midi.Offset);
 if (note == null)
   text = NoteText(midi.Offset) + midi.Octave.toString();
 else
   text = note.Text + midi.Octave.toString();
 
 return new PlayNote(midiNum, text);
}

function AddToRecordBuffer(recordThing)
{
 var i, rt;

 for(i=0; i<m_arrRecordBuffer.length; i++)
  {
   rt = m_arrRecordBuffer[i];
   if (recordThing.RecordType == rt.RecordType)
    {
     switch(recordThing.RecordType)
      {
       case "N":
        {
         if (recordThing.Note.Midi.Offset == rt.Note.Offset && recordThing.Note.Midi.Octave == rt.Note.Octave)
           return false;
        } break;
       case "C":
        {
         if (recordThing.Chord.Pattern == rt.Chord.Pattern && 
             recordThing.Chord.Notes[0].Midi.Offset == rt.Chord.Notes[0].Midi.Offset &&
             recordThing.Chord.Notes[0].Midi.Octave == rt.Chord.Notes[0].Midi.Octave)
           return false;
        } break;
       case "S":
        {
         if (recordThing.Scale.Text == rt.Scale.Text && 
             recordThing.Scale.Notes[0].Midi.Offset == rt.Scale.Notes[0].Midi.Offset &&
             recordThing.Scale.Notes[0].Midi.Octave == rt.Scale.Notes[0].Midi.Octave)
           return false;
        } break;
       default: throw new Error("AddToRecordBuffer(recordThing) invalid RecordType");
      }
    }
  }
 m_arrRecordBuffer.push(recordThing);
 return true;
}

function NoteText(iOffset) // this exists to provide note info if the note is out of key
{
 var offset;

 if (iOffset > 11)
   offset = iOffset - 12;
 else  
   offset = iOffset;

 switch(offset)
  {
   case  0: return "C";
   case  1: return "C" + symSharp + "/" + "D" + symFlat;
   case  2: return "D";
   case  3: return "D" + symSharp + "/" + "E" + symFlat;
   case  4: return "E";
   case  5: return "F";
   case  6: return "F" + symSharp + "/" + "G" + symFlat;
   case  7: return "G";
   case  8: return "G" + symSharp + "/" + "A" + symFlat;
   case  9: return "A";
   case 10: return "A" + symSharp + "/" + "B" + symFlat;
   case 11: return "B";
  }
}

// if I want a spread with a total of 3
// 2 needs to be about half and 3 the final color
// 

function GetBlueGreenColor(ndx, total) // returns color string, ndx is which color, total is the number of colors in the spread
{
 // the classic ratio problem
 // actual is to ndx as total is to arr.length
 // ratio actual:ndx is equivalent to total:arr.length
 // that is actual/ndx = total/arr.length
 // solve for actual would be:  actual = (total/arr.length) * ndx

 var actual;
 var fltval;

 if (total == 0) 
   throw new Error("total cannot be 0");

 if (total > m_arrGradientBlueGreen.length)
   throw new Error("total is > than array of colors");

 if (ndx == 0)
   return m_arrGradientBlueGreen[0];

 if (ndx == total)
   return m_arrGradientBlueGreen[m_arrGradientBlueGreen.length - 1];

 if (total == m_arrGradientBlueGreen.length) // no algebra required
   return m_arrGradientBlueGreen[ndx];  

 fltval = (total / m_arrGradientBlueGreen.length) * ndx;

 actual = Math.round(fltval);

 return m_arrGradientBlueGreen[actual];
}

function GetWhichNoteInChord(chord, offset, midi)  // chord is ndx to m_arrChordPatterns, offset is chord starting note  c = 0, midiRoot is chord's midi root, midi note #
{
 var pat = m_arrChordPatterns[chord];
 var off = m_mapMidiNotes.get(midi).Offset;  // get offset of midi note, c = 0
 var note;
 var i;

 for(i=0; i<pat.Pitches.length; i++) // 1st pitch is always 0 for the root
  {
   note = offset + pat.Pitches[i]; // pitches are not steps between notes, they are the distance from the root
   if (note >= 12)
     note -= 12;
   if (note == off)
     return i;
  }

 return -1;
}

// Get base midi note from current instrument

function GetBaseMidiNote(keyTonic)
{
 var base;
 var midi;

 if (keyTonic < 0 || keyTonic > 11)
   throw new Error("GetBaseMidiNote(arg) arg is out of range");

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   base = m_arrGuitar[0][0]; break;
   case m_Bass:     base = m_arrBass[0][0]; break;
   case m_Mandolin: base = m_arrMandolin[0][0]; break;
   case m_Ukulele:  base = m_arrUkulele[1][0]; break;  // uku's 1st string is higher than 2nd
   case m_Keyboard: return 48;  // no array 
  }
 while(true)
  {
   midi = m_mapMidiNotes.get(base);
   if (midi.Offset == keyTonic)
    {
     return base; // hopefully this won't infinite loop
    }
   base++;
  }
}

// Sound Engine

function Bump16th(time)
{
 var signature 
 switch(m_CurrentTimeSignature)
  {
   case 1: // 4/4 time
    { 
     switch(time)
      {
       case 1:  return 16; // whole note 
       case 2:  return 8;  // half note
       case 4:  return 4;  // quarter note
       case 8:  return 2;  // eighth note
       case 16: return 1;  // 1/16th note
      }
    } break;
   case 2: // 3/4 time
    { 
     switch(time)
      {
       case 1:  return 12; // whole note 
       case 2:  return 8;  // half note, still 2 quarter notes
       case 4:  return 4;  // quarter note
       case 8:  return 2;  // eighth note
       case 16: return 1;  // 1/16th note
      }
    } break;
   case 3: // 2/4 time
    { 
     switch(time)
      {
       case 1:  return 8;  // whole note 
       case 2:  return 8;  // half note
       case 4:  return 4;  // quarter note
       case 8:  return 2;  // eighth note
       case 16: return 1;  // 1/16th note
      }
    } break;
   case 1: // 6/8 time
    { 
     switch(time)
      {
       case 1:  return 24; // whole note 
       case 2:  return 8;  // half note
       case 4:  return 4;  // quarter note
       case 8:  return 2;  // eighth note
       case 16: return 1;  // 1/16th note
      }
    } break;
  }
}

function AddNoteToStave(buffNdx)
{
 var time;
 var pt;
 var vol;
 var note;

 vol = document.getElementById("audioVolumeRecord").value;
 time = parseInt(document.getElementById("cboTime").options[document.getElementById("cboTime").selectedIndex].value);

 note = new PlayNote(m_arrRecordBuffer[buffNdx].Note.Midi.Number, m_arrRecordBuffer[buffNdx].Note.Text);

 pt = new PlayThing("N", note, null, m_CurrentWave, vol, time); // time is passed as 1, 2, 4, 8, 16 then converted to fraction in constructor, 1/4, 1/16

 if (m_CurrentPlaySixteenth >= m_arrPlayBuffers[m_CurrentPlayBuffer].length)
   return;

 ComposePlayNoteSound(note);

 m_arrPlayBuffers[m_CurrentPlayBuffer][m_CurrentPlaySixteenth] = pt;
 m_CurrentPlaySixteenth += Bump16th(time);
 ShowPlayBuffer();
}

function AddChordToStave(buffNdx)
{
 var chord;
 var time;
 var pt;
 var vol;

 vol = document.getElementById("audioVolumeRecord").value;
 time = parseInt(document.getElementById("cboTime").options[document.getElementById("cboTime").selectedIndex].value); 

 // have to construct a new PlayChord object to retain current octave

 chord = new PlayChord(m_arrRecordBuffer[buffNdx].Chord.Mode, m_arrRecordBuffer[buffNdx].Chord.KeyIndex, m_arrRecordBuffer[buffNdx].Chord.Pattern, m_arrRecordBuffer[buffNdx].Chord.Notes[0].Midi.Number);
 
 pt = new PlayThing("C", null, chord, m_CurrentWave, vol, time); // notes of chords to be played simutaneously

 if (m_CurrentPlaySixteenth >= m_arrPlayBuffers[m_CurrentPlayBuffer].length)
   return;

 m_arrPlayBuffers[m_CurrentPlayBuffer][m_CurrentPlaySixteenth] = pt;
 m_CurrentPlaySixteenth += Bump16th(time);

 ComposePlayChordSound(m_arrRecordBuffer[buffNdx].Chord);

 ShowPlayBuffer();
}

function AddChordNoteToStave(buffNdx, noteNdx)
{
 var time;
 var pt;
 var vol;
 var note;

 vol = document.getElementById("audioVolumeRecord").value;
 time = parseInt(document.getElementById("cboTime").options[document.getElementById("cboTime").selectedIndex].value);

 note = new PlayNote(m_arrRecordBuffer[buffNdx].Chord.Notes[noteNdx].Midi.Number, m_arrRecordBuffer[buffNdx].Chord.Notes[noteNdx].Text); 

 pt = new PlayThing("N", note, null, m_CurrentWave, vol, time); // time is passed as 1, 2, 4, 8, 16 then converted to fraction in constructor, 1/4, 1/16
 
 if (m_CurrentPlaySixteenth >= m_arrPlayBuffers[m_CurrentPlayBuffer].length)
   return;

 ComposePlayNoteSound(note);

 m_arrPlayBuffers[m_CurrentPlayBuffer][m_CurrentPlaySixteenth] = pt;
 m_CurrentPlaySixteenth += Bump16th(time);
 ShowPlayBuffer();
}

function AddScaleNoteToStave(buffNdx, noteNdx)
{
 var time;
 var pt;
 var vol;
 var note;

 vol = document.getElementById("audioVolumeRecord").value;
 time = parseInt(document.getElementById("cboTime").options[document.getElementById("cboTime").selectedIndex].value);

 note = new PlayNote(m_arrRecordBuffer[buffNdx].Scale.Notes[noteNdx].Midi.Number, m_arrRecordBuffer[buffNdx].Scale.Notes[noteNdx].Text); 

 pt = new PlayThing("N", note, null, m_CurrentWave, vol, time); // time is passed as 1, 2, 4, 8, 16 then converted to fraction in constructor, 1/4, 1/16
 
 if (m_CurrentPlaySixteenth >= m_arrPlayBuffers[m_CurrentPlayBuffer].length)
   return;

 ComposePlayNoteSound(note);

 m_arrPlayBuffers[m_CurrentPlayBuffer][m_CurrentPlaySixteenth] = pt;
 m_CurrentPlaySixteenth += Bump16th(time);
 ShowPlayBuffer();
}

function ScaleOctaveFwd(buffNdx)
{
 var thing;
 var maxed;
 var midi;
 var i;
 
 thing = m_arrRecordBuffer[buffNdx];
 for (i=0; i<thing.Scale.Notes.length; i++)
  {
   midi = thing.Scale.Notes[i].Midi.Number + 12;
   if (m_mapMidiNotes.get(midi) == undefined)
     maxed = true; 
  }

 if (maxed == true)
   return;
 
 for (i=0; i<thing.Scale.Notes.length; i++)
  {
   midi = thing.Scale.Notes[i].Midi.Number + 12;
   thing.Scale.Notes[i].Midi = m_mapMidiNotes.get(midi); 
  }
 ShowRecordBuffer();
}

function ScaleOctaveBack(buffNdx) // transpose a scale's notes down an octave
{
 var thing;
 var maxed;
 var midi;
 var i;

 thing = m_arrRecordBuffer[buffNdx];
 for (i=0; i<thing.Scale.Notes.length; i++)
  {
   midi = thing.Scale.Notes[i].Midi.Number - 12;
   if (m_mapMidiNotes.get(midi) == undefined)
     maxed = true; 
  }

 if (maxed == true)
   return;
 
 for (i=0; i<thing.Scale.Notes.length; i++)
  {
   midi = thing.Scale.Notes[i].Midi.Number - 12;
   thing.Scale.Notes[i].Midi = m_mapMidiNotes.get(midi); 
  }
 ShowRecordBuffer();
}

function ChordOctaveFwd(buffNdx)
{
 var thing;
 var maxed;
 var midi;
 var i;
 
 thing = m_arrRecordBuffer[buffNdx];
 for (i=0; i<thing.Chord.Notes.length; i++)
  {
   midi = thing.Chord.Notes[i].Midi.Number + 12;
   if (m_mapMidiNotes.get(midi) == undefined)
     maxed = true; 
  }

 if (maxed == true)
   return;
 
 for (i=0; i<thing.Chord.Notes.length; i++)
  {
   midi = thing.Chord.Notes[i].Midi.Number + 12;
   thing.Chord.Notes[i].Midi = m_mapMidiNotes.get(midi); 
  }
 ShowRecordBuffer();
}

function ChordOctaveBack(buffNdx) // transpose a scale's notes down an octave
{
 var thing;
 var maxed;
 var midi;
 var i;

 thing = m_arrRecordBuffer[buffNdx];
 for (i=0; i<thing.Chord.Notes.length; i++)
  {
   midi = thing.Chord.Notes[i].Midi.Number - 12;
   if (m_mapMidiNotes.get(midi) == undefined)
     maxed = true; 
  }

 if (maxed == true)
   return;
 
 for (i=0; i<thing.Chord.Notes.length; i++)
  {
   midi = thing.Chord.Notes[i].Midi.Number - 12;
   thing.Chord.Notes[i].Midi = m_mapMidiNotes.get(midi); 
  }
 ShowRecordBuffer();
}


function PlayScaleSound(playScale, direction) // PlayScale object
{
 var playThing;
 var recordThing;
 var vol;
 var i;

 vol = m_MasterVol;

 if (m_RecordMode == true)
  {
   recordThing = new RecordThing("S", null, null, playScale);
   AddToRecordBuffer(recordThing);
   return;
  }

 if (m_CurrentGUIThing >= 0)
   return; // something already playing

 m_arrGUIThings = [];
 
 for (i=0; i<playScale.Notes.length; i++)
  {
   playThing = new PlayThing("N", playScale.Notes[i], null, m_CurrentWave, vol, 8); // 8th notes
   m_arrGUIThings[i] = playThing;
  }

 if (direction == "b")
   m_arrGUIThings.reverse();

 m_CurrentGUIThing = 0;
 SoundPlayGUI();
}

function PlayChordSound(playChord) // index to m_arrChordPattern and the chord's midi root
{
 var vol;
 var playThing;
 var chordNote;
 var i;

 vol = m_MasterVol;

 if (m_RecordMode == true)
  {
   AddToRecordBuffer(new RecordThing("C", null, playChord, null));
   return;
  }

 if (m_CurrentGUIThing >= 0)
   return; // something already playing

 m_arrGUIThings = [];

 for (i=0; i<playChord.Notes.length; i++)
  {
   chordNote = new PlayThing("N", playChord.Notes[i], null, m_CurrentWave, vol, 8); // single 1/8th notes
   m_arrGUIThings.push(chordNote);
  }

 m_arrGUIThings.push(new PlayThing("R", null, null, m_CurrentWave, vol, 4));
 playThing = new PlayThing("C", null, playChord, m_CurrentWave, vol, 4); // 1/4 time chord 
 m_arrGUIThings.push(playThing);

 m_CurrentGUIThing = 0;
 SoundPlayGUI(); 
}

function ComposePlayChordSound(playChord) // index to m_arrChordPattern and the chord's midi root
{
 var vol;
 var playThing;

 vol = parseFloat(document.getElementById("audioVolumeRecord").value);

 if (m_CurrentGUIThing >= 0)
   return; // something already playing

 m_arrGUIThings = [];

 playThing = new PlayThing("C", null, playChord, m_CurrentWave, vol, 4); // 1/4 time chord 
 m_arrGUIThings.push(playThing);

 m_CurrentGUIThing = 0;
 SoundPlayGUI(); 
}


function PlayNoteSound(playNote)
{
 var vol;
 var playThing;

 vol = m_MasterVol;

 playThing = new PlayThing("N", playNote, null, m_CurrentWave, vol, 8);

 if (m_RecordMode == true)
  {
   AddToRecordBuffer(new RecordThing("N", playNote, null, null));
   return;
  }
 
 if (m_CurrentGUIThing >= 0)
   return; // something already playing

 m_arrGUIThings = [];
 m_arrGUIThings[0] = playThing;
 m_CurrentGUIThing = 0;
 SoundPlayGUI(); 
}

function ComposePlayNoteSound(playNote)
{
 var vol;
 var playThing;

 vol = document.getElementById("audioVolumeRecord").value;

 playThing = new PlayThing("N", playNote, null, m_CurrentWave, vol, 8);
 
 if (m_CurrentGUIThing >= 0)
   return; // something already playing

 m_arrGUIThings = [];
 m_arrGUIThings[0] = playThing;
 m_CurrentGUIThing = 0;
 SoundPlayGUI(); 
}


function SoundPlayThingGUI(playThing, milliPerMeasure)
{
 var oscillators = []; 
 var midiNote;
 var notes;
 var volume;
 var i;

 if (m_Audio == null)
   m_Audio = new(window.AudioContext || window.webkitAudioContext)();

 switch(playThing.PlayType)
  {
   case "C": notes = playThing.Chord.Notes; break;
   case "N": notes = [playThing.Note]; break;
   case "R": notes = []; break;
   default: throw new Error("SoundPlayThing(playThing) bad plaything type");
  }

 volume = m_Audio.createGain();
 volume.connect(m_Audio.destination);
 volume.gain.value = parseFloat(playThing.Volume);

 for (i=0; i<notes.length; i++)
  {
   if (playThing.PlayType != "R")
    {
     midiNote = m_mapMidiNotes.get(notes[i].Midi.Number); // so only Note objects should make it to this point

     oscillators[i] = m_Audio.createOscillator(); // create the player
     oscillators[i].type = playThing.WaveType;
     oscillators[i].connect(volume);
     oscillators[i].frequency.value = midiNote.Frequency;
     oscillators[i].start();
     setTimeout(function() { for (i=0; i<oscillators.length; i++) oscillators[i].stop(); }, playThing.Time * milliPerMeasure); 
    }
  }
}

function SoundPlayThingBuffers(playThing, milliseconds)
{
 var oscillators = []; 
 var midiNote;
 var notes, map;
 var volumes = [];
 var i, k, c;
 var ctrl;

 if (m_Audio == null)
  m_Audio = new(window.AudioContext || window.webkitAudioContext)();

 switch(playThing.PlayType)
  {
   case "C": notes = playThing.Chord.Notes; break;
   case "N": notes = [playThing.Note]; break;
   default: throw new Error("SoundPlayThing(playThing) bad plaything type");
  }

 for (i=0; i<m_arrPlayInstTDs.length; i++)
  {
   ctrl = document.getElementById(m_arrPlayInstTDs[i]);
   if (ctrl != null)
     ctrl.style.backgroundColor = "white";
  }

 m_arrPlayInstTDs = [];
 c = 0;

 for (i=0; i<notes.length; i++)
  {
   midiNote = m_mapMidiNotes.get(notes[i].Midi.Number);  // so only Note objects should make it to this point

   if (m_mapPlayInst.has(midiNote.Number) == true)
    {
     map = m_mapPlayInst.get(midiNote.Number);
     for (k=0; k<map.length; k++)
      {
       ctrl = document.getElementById(map[k]);
       if (ctrl != null)
        {
         ctrl.style.backgroundColor = m_arrGradientBlueGreen[c++];
         m_arrPlayInstTDs.push(map[k]);
        }
       else
        {
         throw new Error("Unable to find id " + map[k]);
        }
      }
    }

   oscillators[i] =m_Audio.createOscillator(); // create the player
   oscillators[i].type = playThing.WaveType;

   volumes[i] =m_Audio.createGain();
   oscillators[i].connect(volumes[i]);
   volumes[i].connect(m_Audio.destination);
   volumes[i].gain.value = playThing.Volume;
   oscillators[i].frequency.value = midiNote.Frequency;
   oscillators[i].start();
   setTimeout(function() { var k; for (k=0; k<oscillators.length; k++) oscillators[k].stop(); }, milliseconds); 
  }
}

function SoundPlayThingsEngine(playThings)
{
 var oscillators;
 var volumes; 
 var midiNote;
 var notes, map;
 var playDurations;
 var playVolumes;
 var playWaves;
 var i, k, c;
 var milliseconds;
 var ctrl;

 if (m_Audio == null)
  m_Audio = new(window.AudioContext || window.webkitAudioContext)();

 oscillators = []; // these contain the individual sound engine objects to play each note note in the current 1/16th time slice
 volumes = [];     // individual volume sound engine objects
 notes = [];       // these are PlayNote objects

 playDurations = []; // durations for each note to play
 playVolumes = [];   // volumes of each note
 playWaves = [];     // wave type for each note

 for (i=0; i<m_arrPlayInstTDs.length; i++)
  {
   ctrl = document.getElementById(m_arrPlayInstTDs[i]);  // clear play instrument
   if (ctrl != null)
     ctrl.style.backgroundColor = "white";
  }
 
 for (i=0; i<playThings.length; i++)
  {
   switch(playThings[i].PlayType) // chord or note?
    {
     case "C": 
      {
       for (k=0; k<playThings[i].Chord.Notes.length; k++) // add individual chord notes to play
        { 
         notes.push(playThings[i].Chord.Notes[k]);
         playDurations.push(playThings[i].Time);
         playVolumes.push(playThings[i].Volume);
         playWaves.push(playThings[i].WaveType);
        }
      } break;
     case "N": 
      {
       notes.push(playThings[i].Note);             // add the single note to play
       playDurations.push(playThings[i].Time);
       playVolumes.push(playThings[i].Volume);
       playWaves.push(playThings[i].WaveType);
      } break;
     default: throw new Error("SoundPlayThingsEngine(playThings) bad plaything type");
    }
  }

 m_arrPlayInstTDs = [];
 c = 0;

 for (i=0; i<notes.length; i++)  // go thru the list of notes
  {
   midiNote = m_mapMidiNotes.get(notes[i].Midi.Number);  // so only Note objects should make it to this point

   if (m_mapPlayInst.has(midiNote.Number) == true)
    {
     map = m_mapPlayInst.get(midiNote.Number);
     for (k=0; k<map.length; k++)
      {
       ctrl = document.getElementById(map[k]);
       if (ctrl != null)
        {
         ctrl.style.backgroundColor = m_arrGradientBlueGreen[c++];
         m_arrPlayInstTDs.push(map[k]);
        }
       else
        {
         throw new Error("Unable to find id " + map[k]);
        }
      }
    }

   milliseconds = playDurations[i] * m_CurrentPlayTime * m_CurrentPlayPercLenth;  // playDurations contain fractions 1/4, 1/8, 1/16th, in decimal format. m_CurrentPlayTime is length of a "measure" 

   oscillators[i] = m_Audio.createOscillator(); // create the player
   oscillators[i].type = playWaves[i];          // playWaves are either "square", "sine", "triangle" or "sawtooth"
   volumes[i] =m_Audio.createGain();            // create a Gain object
   oscillators[i].connect(volumes[i]);          // connect it
   volumes[i].connect(m_Audio.destination);     // connect the audio engine to it
   volumes[i].gain.value = playVolumes[i];      // set the actual volume 
   oscillators[i].frequency.value = midiNote.Frequency;       // frequency of the oscillator
   oscillators[i].start();                                    // play the note
   setTimeout(StopOscillator, milliseconds, oscillators[i]);  // tell the browser to stop playing the note after the given duration is finished
  }
}

function StopOscillator(osc)
{
 osc.stop(); // stop playing the given note
}

function SoundPlayGUI()
{
 var delay;  // find the longest delay and wait that length
 var pt;

 if (m_CurrentGUIThing < m_arrGUIThings.length && m_CurrentGUIThing >= 0)
  {
   pt = m_arrGUIThings[m_CurrentGUIThing];
   delay = pt.Time * m_GUITime;
   SoundPlayThingGUI(pt, m_GUITime);
   m_CurrentGUIThing++;
   if (m_CurrentGUIThing < m_arrGUIThings.length)
     setTimeout(function() { SoundPlayGUI(); }, delay); // advance to next PlaySet
   else
     m_CurrentGUIThing = -1;
  }
}

function FindLastThing(buffer)
{
 var i;

 for (i=m_arrPlayBuffers[buffer].length - 1; i>=0; i--)
  {
   if (m_arrPlayBuffers[buffer][i] != null)
     return i + 1;
  }
 return 0; // none found
}

function SoundPlayCheckedBuffers()
{
 var last, final, none;
 var i;

 if (m_CurrentGUIThing >= 0 || m_PlaySixteenthIndex >=0)  // check if stuff is already playing
   return;

 final = 0;
 none = true;
 for (i=0; i<m_arrPlayBuffers.length; i++)  // go thru checked buffers and find the last note
  {
   if (document.getElementById("chkPlayBuffer" + i).checked == true)
    {
     none = false;
     last = FindLastThing(i);
     if (last > final)
       final = last;
    }
  }

 if (none == true)
  {
   alert("No items are checked to play");
   return;
  }

 if (final == 0)
  {
   alert("No notes or chords were added to a staff");
   return;
  }

 document.getElementById("btnPlay").disabled = true; 

 m_PlaySixteenthEnd = final;

 m_PlaySixteenthIndex = 0;
 SoundPlayBuffers();
}

function SoundPlayBuffers()
{
 var t16;
 var pt;
 var things;
 var i;

 t16 = m_CurrentPlayTime/16; // a measure delay divided by 16 is a 16th note duration
 things = []; 

 if (m_PlaySixteenthIndex < m_PlaySixteenthEnd && m_PlaySixteenthIndex >= 0) // indexes still in range?
  {
   for (i=0; i<m_arrPlayBuffers.length; i++)  // check each buffer at current 16th note step index
    {
     if (document.getElementById("chkPlayBuffer" + i).checked == true)
      {
       pt = m_arrPlayBuffers[i][m_PlaySixteenthIndex]; // see if a play object is present
       if (pt != null)                                 // null's are basically a rest
        {
         things.push(pt);  // add to the list of things to play for this 1/16 note time slice
        }
      }
    }
   if (things.length > 0)      // find anything?
       SoundPlayThingsEngine(things);  // yup, play 'em all
   m_PlaySixteenthIndex++;     // move index to next 16th note instance
   if (m_PlaySixteenthIndex < m_PlaySixteenthEnd) // still in range?
     setTimeout(function() { SoundPlayBuffers(); }, t16); // yes, advance to next 1/16th note slice
   else
    {
     m_PlaySixteenthIndex = -1; // not in range, turn off sound engine 
     document.getElementById("btnPlay").disabled = false;
    }
  }
}

function TestVolume()
{
 var chord, high, low, vol, things, wave;

 chord = new PlayChord(0, 0, m_cpMajor, 53);  // F major
 high = new PlayNote(67, null);               // G5
 low  = new PlayNote(38, null);               // D2

 vol = m_MasterVol;
 wave = m_CurrentWave;

 things = []; 

 things.push(new PlayThing("C", null, chord, wave, vol, 2));
 things.push(new PlayThing("N", high, null, wave, vol, 2));
 things.push(new PlayThing("N", low, null, wave, vol, 2));

 SoundPlayThingsEngine(things);

}

////////////////////////////////////////////////
//       G e n e r a t e    H T M L
////////////////////////////////////////////////

// GenStringCell
// index to chord pattern, offset c=0, key is Key object, midiNote #, width is cell size
// open & barre are fingering letter, barreShowNote boolean, noData is boolean no chord or barre chord info, tuning is m_CurrentGuitarTuning for stringed

function GenStringCell(chord, key, offset, midiNote, width, open, barre, barreShowNote, noData, tuning) 
{
 var html;
 var note, chordNote, whichNote;
 var inChord;
 var preNote;
 var bg, fg, colorNdx;
 var midi;

 midi = m_mapMidiNotes.get(midiNote);                         // get Midi object
 note = key.OffsetNote(midi.Offset);
 if (note != null)
   colorNdx = key.NoteIndex(key.OffsetNote(midi.Offset));          // get which note of the key the midi is, 0 = tonic
 else
   colorNdx = -1;
 whichNote = GetWhichNoteInChord(chord, offset, midiNote);
 if (whichNote < 0)
   inChord = false;
 else
   inChord = true;
 
 if (key.LookUp[midi.Offset] >= 0) // determine if midi note is in the key
   preNote = midi.MidiName(key);    // it is, figure out the display, either natural or flat/sharp based on the key
 else 
   preNote = NoteText(midi.Offset) + "(" + midi.Octave.toString() + ")";  // it is not in the key, so can't determine sharp or flat so just include both names, example D#/Eb

 note = preNote;
 if (inChord == true)
   chordNote = preNote;
 else
   chordNote = "";

 if (tuning == 0 && noData == false) // is it standard tuning and there is data on how to play the chord?
  {
   if (open == "" && barre == "")
    {
     note = "";
    }
   else 
    {
     if (open == "X" || barre == "X")
       note = "";
     else 
      {
       if (barre == m_arrFingering[0])
        {
         if (barreShowNote == 0)
           note = "";
        }
      }
    }
  }
 else // non standard tuning or there is no data how to play the chord then just show notes that are in the chord
  {
   open = "";
   barre = "";
   if (inChord == false)
    {
     note = "";
    }   
  }

 if (note != "")
  {
   if (colorNdx < 0)
     bg = blueNote;
   else
     bg = m_arrGradientBlueGreen[colorNdx]; 
  }
 else
  {
   bg = "#ffffff";
  }

 if (chordNote != "" && note == "")
  fg = "#555555";
 else
  fg = "#000000";

 html = "<div class='fretCell' style='width:" + width.toString() + "vw; color:" + fg + "; background-color:" + bg + "'>";
 html += chordNote;
 if (chordNote !="")
  {
   html += "<BR><div class='fretCellInfo'>";
   html += m_arrChordPatterns[chord].PitchNames[whichNote];
   html += "</div>";
  }
 
 if (open != "")
   html += "<div class='fretCellLeft'>" + open + "</div>";

 if (barre != "")
   html += "<div class='fretCellRight'>" + barre + "</div>";

 html += "</div>";

 return html;
}

// return HTML for a string / fret cell for the scale fretboard

function GenStringCellScale(width, midiNote, scaleNum, notes)
{
 var html;
 var oMidi; 
 var note;
 var text;
 var i;

 oMidi = m_mapMidiNotes.get(midiNote);
 note = null;
 for (i=0; i<notes.length; i++)
  {
   if (notes[i].Offset == oMidi.Offset)
     note = notes[i];
  }

 if (note == null)
   text ="";
 else
   text = oMidi.MidiNameViaNote(note);   

 if (scaleNum == 0)
  {
   text = "";
  }

 html = "<div class='fretCell' style='width:" + width.toString() + "vw;'>";
 html += text;

 if (scaleNum > 0)
   html += "<br><div class='fretCellInfo'>" + scaleNum.toString() + "</div>";

 html += "</div>";

 return html;
}

function GenChordInfo(chord, offset, key, midiRoot) // chord pattern index, offset is chord's starting note C = 0, Key object
{
 var pattern;
 var html;
 var note, noteText;
 var p, k;
 var midi;
 var color;

 pattern = m_arrChordPatterns[chord]; // grab ChordPattern from modes array so it can step up through the notes
 
 note = key.OffsetNote(offset);
 if (note == null)
   noteText = NoteText(offset);
 else
   noteText = note.Text;

 html = "<table>"; 

 html += "<tr><td class='chordInfo' onclick='PlayChordSound(new PlayChord(" + m_CurrentMode + ", " + m_CurrentKey + ", " + chord.toString() + "," + midiRoot.toString() + "));' colspan=2>" + noteText;
 html += pattern.ShortName;
 html += "</td></tr>";

 for (p=0; p<pattern.Pitches.length; p++)
  {
   midi = midiRoot + pattern.Pitches[p];
   k = offset + pattern.Pitches[p];
   if (k>11)
     k -= 12;

  if (p > 0)
   {
    html += "<TR><TD class='chordFormula'>"; 
    switch(p)
     {
      case 1: html += pattern.Third; break;
      case 2: html += pattern.Fifth; break;
      case 3: html += pattern.Seventh; break;
      case 4: html += pattern.Ninth; break;
     }
    html += "<TD class='chordStep'>" + pattern.Pitches[p].toString() + "</TD>";
    html += "</TD></TR>";
   }

   note = key.OffsetNote(k);
   if (note == null)
    {
     noteText = NoteText(k);
     color = blueNote;
    }
   else
    { 
     noteText = note.Text;
     color = m_arrGradientBlueGreen[key.NoteIndex(note)];
    }

   html += "<TR><TD class='chordNote' onclick='PlayNoteSound(new PlayNote(" + midi.toString() + ", " + Quotes(noteText) + "));' style='color:#000044; background-color:" + color + ";' colspan=2>";

   noteText += "<BR><div class='fretCellInfo'>";
   noteText += pattern.PitchNames[p];
   noteText += "</div>";

   html += noteText; // dm7 0-3-7-10 :  2 = d, 5 = f, 9 = a, 12  = c
   html += "</TD></TR>";
  }

 html += "</table>";

 return html;
}

function GenScaleInfo(key) // chord pattern index, offset C = 0, Key object
{
 var s="";
 var i;
 var midi = key.BaseMidi; // 48 is C3

 for (i=0;i<m_arrModes[m_CurrentMode].Sequences.length;i++)
  {
   s += "<TD class='scaleNote' style='background-color:" + m_arrGradientBlueGreen[i] + ";' onclick='PlayNoteSound(new PlayNote(" + midi.toString() + ", " + Quotes(m_Key.Notes[i].Text) + "));'>";
   s += m_Key.Notes[i].Text;
   s += "</TD>";

   midi += m_arrModes[m_CurrentMode].Sequences[i]; // have to increment midi after it's consumed above

   s+="<TD class='modeSequence'>"; 
   switch(m_arrModes[m_CurrentMode].Sequences[i])
    {
     case 1: s+="h<BR />1"; break;
     case 2: s+="W<BR />2"; break;
     case 3: s+="m3<BR />3"; break;
     case 4: s+="M 3<BR />4"; break;
    }
   s+="</TD>";
  }

 s += "<TD class='scaleNote' style='background-color:" + m_arrGradientBlueGreen[m_arrModes[m_CurrentMode].Sequences.length] + ";' onclick='PlayNoteSound(new PlayNote(" + midi + ", " + Quotes(m_Key.Notes[0].Text) + "));'>";
 s += m_Key.Notes[0].Text;
 s += "</TD>";

 return s;
}

function GenOtherScaleInfo(key, notes) // Key object, array of Note objects
{
 var s="";
 var i;
 var midiNum, midi;
 var keyNdx;
 var color;
 var note, noteText;

 midiNum = key.BaseMidi + notes[0].Offset;     // 48 is C3


 for (i=0;i<m_arrScales[m_CurrentScale].Sequences.length;i++) // walk up the scale
  {   
   midi = m_mapMidiNotes.get(midiNum); // get the midi object for the scale's current midi number
   note = notes[i];                // get Note object from the notes array
   noteText = note.Text;          // note text for html
   keyNdx = key.NoteIndex(note);  // see if note is key 
   if (keyNdx < 0) 
    {
     color = blueNote;       // note is out of key, color it blue
    }
   else
    { 
     color = m_arrGradientBlueGreen[keyNdx];  // the gradient 
    }

   s += "<TD class='scaleNote' style='background-color:" + color + ";' onclick='PlayNoteSound(new PlayNote(" + midiNum.toString() +", " + Quotes(noteText) + "));'>";
   s += noteText;
   s += "</TD>";

   midiNum += m_arrScales[m_CurrentScale].Sequences[i]; // have to increment midi after it's consumed above

   s+="<TD class='modeSequence'>"; 
   switch(m_arrScales[m_CurrentScale].Sequences[i])  // include the scale formula step letter
    {
     case 1: s+="h<BR />1"; break;
     case 2: s+="W<BR />2"; break;
     case 3: s+="m3<BR />3"; break;
     case 4: s+="M 3<BR />4"; break;
    }
   s+="</TD>";
  }

 s += "<TD class='scaleNote' style='background-color:" + m_arrGradientBlueGreen[m_arrScales[m_CurrentScale].Sequences.length] + ";' onclick='PlayNoteSound(new PlayNote(" + midiNum.toString() + ", " + Quotes(notes[0].Text) + "));'>";
 s += notes[0].Text;  // add the octave to the html
 s += "</TD>";

 return s;
}

function genModeChords()
{
 var pattern;
 var s;
 var cn;
 var midi;
 var i;
 
 s="<TABLE>";
 s+="<TR><TD class='scaleInfo'>Chord Progression</TD>";

 cn = m_Key.Offset;
 midi = m_Key.BaseMidi;  // c3 plus the offset

 for (i=0;i<m_arrModes[m_CurrentMode].Sequences.length;i++)
  {
   pattern = m_arrModes[m_CurrentMode].ChordType[i];

   s += "<TD class='modeChord' onclick='PlayChordSound(new PlayChord(" + m_CurrentMode + ", " + m_CurrentKey + ", " + pattern + "," + midi.toString() + "));'>";
   
   s += m_Key.OffsetNote(cn).Text;
   s += m_arrChordPatterns[pattern].ShortName;
   s += "</TD>";

   s+="<TD class='modeSequence'>"; 
   switch(m_arrModes[m_CurrentMode].Sequences[i])
    {
     case 1: s+="h<BR />1"; break;
     case 2: s+="W<BR />2"; break;
     case 3: s+="m3<BR />3"; break;
     case 4: s+="M 3<BR />4"; break;
    }
   s+="</TD>";

   midi += m_arrModes[m_CurrentMode].Sequences[i];
   cn += m_arrModes[m_CurrentMode].Sequences[i];
   if (cn >= 12)
     cn -= 12;
  }

 pattern = m_arrModes[m_CurrentMode].ChordType[0];

 s += "<TD class='modeChord' onclick='PlayChordSound(new PlayChord(" + m_CurrentMode + ", " + m_CurrentKey + ", " + pattern + "," + midi.toString() + "));'>";
 
 s += m_Key.OffsetNote(m_Key.Offset).Text;
 s += m_arrChordPatterns[pattern].ShortName;
  
 s += "</TD>";

 s+="</TR><TR></TABLE>";

 return s;
}

////////////////////////////////////////////////
//                 G u i t a r     
////////////////////////////////////////////////

// generate guitar fretboard
// returns a open chord fingering letter I,M,R,P or O, X based on string and fret
// m_arrChordPatterns has been prepared that contain the fingering

function GenGuitarStringElement(chord, offset, wstr, fret) // chord = chord pattern index, offset c=0, wstr is string #, fret # nut is 0
{
 var i, k, capo, off;

 capo = m_CurrentGuitarCapo;
 off = offset - capo;  // so if offset was c# and capo == 1, off will be set to "c", the pattern that will play a c# chord if capo is on fret 1
 if (off < 0)
   off += 12;

 // if offset == c#  and capo == 1 then show the "C" chord up one fret 

 for (i=0; i<m_arrChordPatterns[chord].PatternGuitar.length; i++) // go thru the placements
  {
   if (m_arrChordPatterns[chord].PatternGuitar[i].Offset == off) // see if offset is present C = 0
    {
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Index.length; k++) // go thru Index finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Index[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Index[k].Fret + capo == fret)
         return m_arrFingering[0]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Middle.length; k++) // go thru middle finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Middle[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Middle[k].Fret + capo == fret)
         return m_arrFingering[1]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Ring.length; k++) // go thru ring finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Ring[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Ring[k].Fret + capo == fret)
         return m_arrFingering[2]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Pinky.length; k++) // go thru pinky finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Pinky[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Pinky[k].Fret + capo == fret)
         return m_arrFingering[3]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Open.length; k++) // go thru open string list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Open[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Open[k].Fret + capo == fret)
         return "O"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].NoPlay.length; k++) // go thru no play finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].NoPlay[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].NoPlay[k].Fret + capo == fret)
         return "X"; 
      }
    }
  }
 return "";
}

// return barre chord fingering I,M,R,P or X based on string and fret
// each barre pattern, E and A types were prepared.
// the Offsets array for each contains the offset to the barre pattern fingering array
// the offset gives the location of the barre chord for the passed offset. For the A and Am pattern C = 0 would return 2 which is the A pattern up the 3rd fret.
// the reason C is not 3 is because the open A is not included in the fingering, only barre chords are present.  

function GenGuitarBarreStringElement(chord, offset, wstr, fret) // ChordPatteren index, offset C=0, String # (low E is 0), fret # (nut is 0)
{ 
 // for barre need to not return fingerings for open A and open E
 var i, k, fo;

 for (i=0; i<m_arrGuitarBarre.length; i++)
  {
   if (m_arrGuitarBarre[i].CP == chord)
    {
     fo = m_arrGuitarBarre[i].Offsets[offset];
     for (k=0; k<m_arrGuitarBarre[i].Index[fo].length; k++)
      {
       if (m_arrGuitarBarre[i].Index[fo][k].Str == wstr && m_arrGuitarBarre[i].Index[fo][k].Fret == fret)
         return m_arrFingering[0];
      }
     for (k=0; k<m_arrGuitarBarre[i].Middle[fo].length; k++)
      {
       if (m_arrGuitarBarre[i].Middle[fo][k].Str == wstr && m_arrGuitarBarre[i].Middle[fo][k].Fret == fret)
         return m_arrFingering[1];
      }
     for (k=0; k<m_arrGuitarBarre[i].Ring[fo].length; k++)
      {
       if (m_arrGuitarBarre[i].Ring[fo][k].Str == wstr && m_arrGuitarBarre[i].Ring[fo][k].Fret == fret)
         return m_arrFingering[2];
      }
     for (k=0; k<m_arrGuitarBarre[i].Pinky[fo].length; k++)
      {
       if (m_arrGuitarBarre[i].Pinky[fo][k].Str == wstr && m_arrGuitarBarre[i].Pinky[fo][k].Fret == fret)
         return m_arrFingering[3];
      }
     for (k=0; k<m_arrGuitarBarre[i].NoPlay[fo].length; k++)
      {
       if (m_arrGuitarBarre[i].NoPlay[fo][k].Str == wstr && m_arrGuitarBarre[i].NoPlay[fo][k].Fret == fret)
         return "X";
      }
    }
  }
 return "";
}

// Show Note gets the ShowNote property of the BarreIndex object for barre chord fingerings
// the Offset lookup system is the same as GenGuitarBarreStringElement above

function GenGuitarBarreShowNote(chord, offset, wstr, fret) // chord (index to m_arrChordPattern), offset c=0, string (low = 0), fret #
{ 
 // for barre need to not return fingerings for open A and open E
 var i, k, fo;

 for (i=0; i<m_arrGuitarBarre.length; i++)
  {
   if (m_arrGuitarBarre[i].CP == chord)
    {
     fo = m_arrGuitarBarre[i].Offsets[offset]; // if offset = 0, C, fo = 2
     for (k=0; k<m_arrGuitarBarre[i].Index[fo].length; k++)
      {
       if (m_arrGuitarBarre[i].Index[fo][k].Str == wstr && m_arrGuitarBarre[i].Index[fo][k].Fret == fret)
         return m_arrGuitarBarre[i].Index[fo][k].ShowNote;
      }
    }
  }
 return 1;
}

function GenGuitarNoData(chord, offset) // returns true if no chord data is found 
{
 var i;

 for (i=0; i<m_arrChordPatterns[chord].PatternGuitar.length; i++) 
  {
   if (m_arrChordPatterns[chord].PatternGuitar[i].Offset == offset) // see if offset is present C = 0
     return false;
  }
 for (i=0; i<m_arrGuitarBarre.length; i++)
  {
   if (m_arrGuitarBarre[i].CP == chord)
     return false;
  }
 return true;
}

// generate a TR html for a guitar string for a specific chord

function GenGuitarString(chord, offset, wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var barre, open, barreShowNote;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; // 40 pixels
 var w;
 var noData;
 var pn;

 for (fret=0; fret<m_arrInstruments[m_Guitar].Frets; fret++)
  {
   midi = m_arrGuitar[wstr][fret]; // get midi note of string and fret
   
   if (fret == 0) // before the nut
     w = fretBeforeNut;   // 25 pixels
   else  
     w = sw;

   pn = GetPlayNote(midi);

   if (fret >= m_CurrentGuitarCapo)
    {
     html += "<td class='fretString' onclick='PlayNoteSound(new PlayNote(" + midi.toString() + ", " + Quotes(pn.Text) + "));'>";

     noData = GenGuitarNoData(chord, offset);        // is there any data on the current chord and offset?
     open = GenGuitarStringElement(chord, offset, wstr, fret); // returns a finger letter or O X  for open chords
     barre = GenGuitarBarreStringElement(chord, offset, wstr, fret); // returns barre equivilent for barre chords
     barreShowNote = GenGuitarBarreShowNote(chord, offset, wstr, fret); // if it's "I" index do I show the note

     html += GenStringCell(chord, key, offset, midi, w, open, barre, barreShowNote, noData, m_CurrentGuitarTuning);  // figure out the html for a fret cell
    }
   else
    {
     html += "<td class='fretString' style='width:" + w.toString() + "vw; background-color:lightgray;'>";
    }  
   html += "</td>";
   sw -=  fretDecrease; // 1 pixel
  }
 html += "</tr>";
 return html;
}

function GenGuitarStringScale(wstr, key, notes) // which string, and an array of Note objects
{
 var midi, midiNum;
 var bg, fg;
 var sn;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; //vw units about 40 pixels on a 1920 display, this is the size of area between the nut and fret 1
 var w, i, keyNdx;
 var note, text, noteText;

 for (fret=0; fret<m_arrInstruments[m_Guitar].Frets; fret++)
  {
   midiNum = m_arrGuitar[wstr][fret];  // get midi # note of string and fret
   midi = m_mapMidiNotes.get(midiNum); // get Midi object
   note = null;
   sn = -1;
   for(i=0; i<notes.length; i++)
    {
     if (midi.Offset == notes[i].Offset)
      {
       sn = i;
       note = notes[i];
       keyNdx = key.NoteIndex(note);
       if (keyNdx >= 0)
         bg = m_arrGradientBlueGreen[keyNdx];
       else
         bg = blueNote;
       fg = "#000044";
       text = note.Text;
      }
    }
   if (note == null)
    {
     text = "";
     bg = "#CCCCCC";
     fg = "white";
    }

   if (fret == 0)        // before the nut
     w = fretBeforeNut;  // 25 pixels
   else  
     w = sw;

   if (text == "")
     noteText = NoteText(midi.Offset);
   else
     noteText = text;

   if (fret >= m_CurrentGuitarCapo)
    {
     html += "<td class='fretString' style='color:" + fg + "; background-color:" + bg + ";' onclick='PlayNoteSound(new PlayNote(" + midiNum + ", " + Quotes(noteText) + "));'>";
     html += "<div class='fretCell' style='width:" + w.toString() + "vw;'>";
     html += text;
     if (sn >= 0)
       html += "<br><div class='fretCellInfo'>" + (sn + 1).toString() + "</div>";
     html += "</div>";
    }
   else
    {
     html += "<td class='fretString' style='width:" + w.toString() + "vw; color:" + fg + "; background-color:lightgray;'>";
    }
   html += "</td>";
   sw -= fretDecrease; // subtract about a pixel on 1920 monitor
  }
 html += "</tr>";
 return html;
}

function GenGuitarMarks()
{
 var html = "<tr>";
 var fret, w;
 var sw = fretMarkStart; // 30 pixels, have to slide this over a bit to line up the dots like a fretboard

 for (fret=0; fret<m_arrInstruments[m_Guitar].Frets; fret++)
  {
   if (fret == 0) // before the nut
    {
     w = fretMarkBeforeNut;   // 15 pixels
    }
   else  
     w = sw;
   html += "<td class='fretMark' style='width:" + w.toString() + "vw;'>";
   if (m_CurrentGuitarCapo > 0 && m_CurrentGuitarCapo == fret)
     html += "Capo";
   else
    {
     if (fret == 0)
       html += "Nut";
     if (fret == 3 || fret == 5 || fret ==7 || fret == 9 || fret == 15 || fret==17 || fret==19) 
       html += symDot;
     if (fret == 12)
       html += symDot + symDot;
    }
   html += "</td>";
   sw -= fretDecrease;
  }

 html += "</tr>";
 return html;
}

function GenGuitar(chord, offset, key) // chord pattern index, offset C=0, Key object
{
 var html;

 html = "<table>";

 html += GenGuitarString(chord, offset, 5, key);
 html += GenGuitarString(chord, offset, 4, key);
 html += GenGuitarString(chord, offset, 3, key);
 html += GenGuitarString(chord, offset, 2, key);
 html += GenGuitarString(chord, offset, 1, key);
 html += GenGuitarString(chord, offset, 0, key);
 html += GenGuitarMarks();

 html += "</table>";
  
 return html;
}

function GenGuitarScale(key)
{
 var html;
 var midiBase = GetBaseMidiNote(key.Offset);

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>"; 
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"f\");'>" + symFwd + "</td>";

 html += GenScaleInfo(key);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenGuitarStringScale(5, key, key.Notes); // returns TRs
 html += GenGuitarStringScale(4, key, key.Notes);
 html += GenGuitarStringScale(3, key, key.Notes);
 html += GenGuitarStringScale(2, key, key.Notes);
 html += GenGuitarStringScale(1, key, key.Notes);
 html += GenGuitarStringScale(0, key, key.Notes);
 html += GenGuitarMarks();

 html += "</table></td></tr></table>";

 return html;
}

function GenGuitarOtherScale(key, notes)
{
 var html;
 var midiBase = GetBaseMidiNote(key.Offset);

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrScales[m_CurrentScale].ScaleName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"f\");'>" + symFwd + "</td>";


 html += GenOtherScaleInfo(key, notes);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenGuitarStringScale(5, key, notes); // returns TRs
 html += GenGuitarStringScale(4, key, notes);
 html += GenGuitarStringScale(3, key, notes);
 html += GenGuitarStringScale(2, key, notes);
 html += GenGuitarStringScale(1, key, notes);
 html += GenGuitarStringScale(0, key, notes);
 html += GenGuitarMarks();

 html += "</table></td></tr></table>";

 return html;
}

function GenGuitarPlayBoard()
{
 var i, k, html;
 var midi, midiNum, sw;
 var td, w;
 
 html = "<table>";
 
 m_mapPlayInst = new Map();

 sw = fretStartSize;
 for (i=m_arrInstruments[m_Guitar].Strings - 1; i>=0; i--)
  {
   html += "<tr>";
   for (k=0; k<m_arrInstruments[m_Guitar].Frets; k++)
    {
     midiNum = m_arrGuitar[i][k]; // get midi note of string and fret
     midi = m_mapMidiNotes.get(midiNum);
     if (k == 0) // before the nut
       w = fretBeforeNut;   // 25 pixels
     else  
       w = sw;
     if (k >= m_CurrentGuitarCapo)
      {
       td = "tdPI_" + i + "_" + k;
       html += "<td class='fretPlay' style='width:" + w + "vw;' id='" + td + "' onclick='ComposePlayNoteSound(new PlayNote(" + midi.toString() + ", null));'>";
       html += NoteText(midi.Offset) + midi.Octave;
       if (m_mapPlayInst.has(midiNum) == true)
         m_mapPlayInst.get(midiNum).push(td);
       else
         m_mapPlayInst.set(midiNum, [td]);  // so the map will contain keys of midi numbers and the value is an array of TD id's that need to be set if the note comes up
      }
     else
      {
       html += "<td class='fretPlay' style='width:" + w.toString() + "vw; background-color:lightgray;'>";
      }  
     html += "</td>";
     sw -=  fretDecrease; // 1 pixel
    }
   html += "</tr>";
  }
 html += GenGuitarMarks();
 html += "</table>"; 

 document.getElementById("divPlayInst").innerHTML = html;
}

////////////////////////////////////////////////
//           B a s s    G u i t a r     
////////////////////////////////////////////////

// generate bass fretboard.  Using the 1st 4 strings of bass fingering patterns.
// returns a open chord fingering letter I,M,R,P or O, X based on string and fret
// m_arrChordPatterns has been prepared that contain the fingering

function GenBassStringElement(chord, offset, wstr, fret) // chord = chord pattern index, offset c=0, wstr is string #, fret # nut is 0
{
 var i, k, capo, off;  

 capo = m_CurrentBassCapo;
 off = offset - capo;  // so if offset was c# and capo == 1, off will be set to "c", the pattern that will play a c# chord if capo is on fret 1
 if (off < 0)
   off += 12;

 for (i=0; i<m_arrChordPatterns[chord].PatternBass.length; i++) // go thru the placements
  {
   if (m_arrChordPatterns[chord].PatternBass[i].Offset == off) // see if offset is present C = 0
    {
     for(k=0; k<m_arrChordPatterns[chord].PatternBass[i].Index.length; k++) // go thru Index finger list
      {
       if (m_arrChordPatterns[chord].PatternBass[i].Index[k].Str == wstr && m_arrChordPatterns[chord].PatternBass[i].Index[k].Fret + capo == fret)
         return m_arrFingering[0]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternBass[i].Middle.length; k++) // go thru middle finger list
      {
       if (m_arrChordPatterns[chord].PatternBass[i].Middle[k].Str == wstr && m_arrChordPatterns[chord].PatternBass[i].Middle[k].Fret + capo == fret)
         return m_arrFingering[1]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].Pattern[i].Ring.length; k++) // go thru ring finger list
      {
       if (m_arrChordPatterns[chord].PatternBass[i].Ring[k].Str == wstr && m_arrChordPatterns[chord].PatternBass[i].Ring[k].Fret + capo == fret)
         return m_arrFingering[2]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternBass[i].Pinky.length; k++) // go thru pinky finger list
      {
       if (m_arrChordPatterns[chord].PatternBass[i].Pinky[k].Str == wstr && m_arrChordPatterns[chord].PatternBass[i].Pinky[k].Fret + capo == fret)
         return m_arrFingering[3]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternBass[i].Open.length; k++) // go thru open string list
      {
       if (m_arrChordPatterns[chord].PatternBass[i].Open[k].Str == wstr && m_arrChordPatterns[chord].PatternBass[i].Open[k].Fret + capo == fret)
         return "O"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternBass[i].NoPlay.length; k++) // go thru no play finger list
      {
       if (m_arrChordPatterns[chord].PatternBass[i].NoPlay[k].Str == wstr && m_arrChordPatterns[chord].PatternBass[i].NoPlay[k].Fret + capo == fret)
         return "X"; 
      }
    }
  }
 return "";
}

// return barre chord fingering I,M,R,P or X based on string and fret
// each barre pattern, E and A types were prepared.
// the Offsets array for each contains the offset to the barre pattern fingering array
// the offset gives the location of the barre chord for the passed offset. For the A and Am pattern C = 0 would return 2 which is the A pattern up the 3rd fret.
// the reason C is not 3 is because the open A is not included in the fingering, only barre chords are present.  

function GenBassBarreStringElement(chord, offset, wstr, fret) // ChordPatteren index, offset C=0, String # (low E is 0), fret # (nut is 0)
{ 
 var i, k, fo;

 for (i=0; i<m_arrBassBarre.length; i++)
  {
   if (m_arrBassBarre[i].CP == chord)
    {
     fo = m_arrBassBarre[i].Offsets[offset];
     for (k=0; k<m_arrBassBarre[i].Index[fo].length; k++)
      {
       if (m_arrBassBarre[i].Index[fo][k].Str == wstr && m_arrBassBarre[i].Index[fo][k].Fret == fret)
         return m_arrFingering[0];
      }
     for (k=0; k<m_arrBassBarre[i].Middle[fo].length; k++)
      {
       if (m_arrBassBarre[i].Middle[fo][k].Str == wstr && m_arrBassBarre[i].Middle[fo][k].Fret == fret)
         return m_arrFingering[1];
      }
     for (k=0; k<m_arrBassBarre[i].Ring[fo].length; k++)
      {
       if (m_arrBassBarre[i].Ring[fo][k].Str == wstr && m_arrBassBarre[i].Ring[fo][k].Fret == fret)
         return m_arrFingering[2];
      }
     for (k=0; k<m_arrBassBarre[i].Pinky[fo].length; k++)
      {
       if (m_arrBassBarre[i].Pinky[fo][k].Str == wstr && m_arrBassBarre[i].Pinky[fo][k].Fret == fret)
         return m_arrFingering[3];
      }
     for (k=0; k<m_arrBassBarre[i].NoPlay[fo].length; k++)
      {
       if (m_arrBassBarre[i].NoPlay[fo][k].Str == wstr && m_arrBassBarre[i].NoPlay[fo][k].Fret == fret)
         return "X";
      }
    }
  }
 return "";
}

// Show Note gets the ShowNote property of the BarreIndex object for barre chord fingerings
// the Offset lookup system is the same as GenBassBarreStringElement above

function GenBassBarreShowNote(chord, offset, wstr, fret) // chord (index to m_arrChordPattern), offset c=0, string (low = 0), fret #
{ 
var i, k, fo;

 for (i=0; i<m_arrBassBarre.length; i++)
  {
   if (m_arrBassBarre[i].CP == chord)
    {
     fo = m_arrBassBarre[i].Offsets[offset]; // if offset = 0, C, fo = 2
     for (k=0; k<m_arrBassBarre[i].Index[fo].length; k++)
      {
       if (m_arrBassBarre[i].Index[fo][k].Str == wstr && m_arrBassBarre[i].Index[fo][k].Fret == fret)
         return m_arrBassBarre[i].Index[fo][k].ShowNote;
      }
    }
  }
 return 1;
}

function GenBassNoData(chord, offset) // returns true if no chord data is found 
{
 var i;

 for (i=0; i<m_arrChordPatterns[chord].PatternBass.length; i++) 
  {
   if (m_arrChordPatterns[chord].PatternBass[i].Offset == offset) // see if offset is present C = 0
     return false;
  }
 for (i=0; i<m_arrBassBarre.length; i++)
  {
   if (m_arrBassBarre[i].CP == chord)
     return false;
  }
 return true;
}

// generate a TR html for a bass string for a specific chord

function GenBassString(chord, offset, wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var barre, open, barreShowNote;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; // 40 pixels
 var noData;
 var w, pn;

 for (fret=0; fret<m_arrInstruments[m_Bass].Frets; fret++)
  {
   midi = m_arrBass[wstr][fret]; // get midi note of string and fret

   if (fret == 0) // before the nut
     w = fretBeforeNut;   // 25 pixels
   else  
     w = sw;

   pn = GetPlayNote(midi);
  
   if (fret >= m_CurrentBassCapo)
    {
     html += "<td class='fretString' onclick='PlayNoteSound(new PlayNote(" + midi.toString() + ", " + Quotes(pn.Text) + "));'>";

     noData = GenBassNoData(chord, offset);
     open = GenBassStringElement(chord, offset, wstr, fret);
     barre = GenBassBarreStringElement(chord, offset, wstr, fret);
     barreShowNote = GenBassBarreShowNote(chord, offset, wstr, fret);

     html += GenStringCell(chord, key, offset, midi, w, open, barre, barreShowNote, noData, m_CurrentBassTuning);
    }
   else
    {
     html += "<td class='fretString' style='width:" + w.toString() + "vw; background-color:lightgray;'>";
    }
   html += "</td>";
   sw -=  fretDecrease; // 1 pixel
  }
 html += "</tr>";
 return html;
}

function GenBassStringScale(wstr, key, notes) // which string, array of Note objects
{
 var midi, midiNum;
 var bg, fg;
 var sn;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; //vw units about 40 pixels on a 1920 display, this is the size of area between the nut and fret 1
 var w, i, keyNdx;
 var note, text, noteText;

 for (fret=0; fret<m_arrInstruments[m_Bass].Frets; fret++)
  {
   midiNum = m_arrBass[wstr][fret];  // get midi # note of string and fret
   midi = m_mapMidiNotes.get(midiNum); // get Midi object
   note = null;
   sn = -1;
   for(i=0; i<notes.length; i++)
    {
     if (midi.Offset == notes[i].Offset)
      {
       sn = i;
       note = notes[i];
       keyNdx = key.NoteIndex(note);
       if (keyNdx >= 0)
         bg = m_arrGradientBlueGreen[keyNdx];
       else
         bg = blueNote;
       fg = "#000044";
       text = note.Text;
      }
    }
   if (note == null)
    {
     text = "";
     bg = "#CCCCCC";
     fg = "white";
    }

   if (text == "")
     noteText = NoteText(midi.Offset);
   else
     noteText = text;

   if (fret == 0)        // before the nut
     w = fretBeforeNut;  // 25 pixels
   else  
     w = sw;

   if (fret >= m_CurrentBassCapo)
    {
     html += "<td class='fretString' style='color:" + fg + "; background-color:" + bg + ";' onclick='PlayNoteSound(new PlayNote(" + midiNum + ", " + Quotes(noteText) + "));'>";
     html += "<div class='fretCell' style='width:" + w.toString() + "vw;'>";
     html += text;
     if (sn >= 0)
       html += "<br><div class='fretCellInfo'>" + (sn + 1).toString() + "</div>";
     html += "</div>";
    }
   else
    {
     html += "<td class='fretString' style='width:" + w.toString() + "vw; color:" + fg + "; background-color:lightgray;'>";
    }
   html += "</td>";
   sw -= fretDecrease; // subtract about a pixel on 1920 monitor
  }
 html += "</tr>";

 return html;
}

function GenBassMarks()
{
 var html = "<tr>";
 var fret, w;
 var sw = fretMarkStart; // 30 pixels, have to slide this over a bit to line up the dots like a fretboard

 for (fret=0; fret<m_arrInstruments[m_Bass].Frets; fret++)
  {
   if (fret == 0) // before the nut
     w = fretMarkBeforeNut;   // 15 pixels
   else  
     w = sw;
   html += "<td class='fretMark' style='width:" + w.toString() + "vw;'>";
   if (m_CurrentBassCapo > 0 && m_CurrentBassCapo == fret)
     html += "Capo";
   else
    {
     if (fret == 0)
       html += "Nut";
     if (fret == 3 || fret == 5 || fret ==7 || fret == 9 || fret == 15 || fret==17 || fret==19) 
       html += symDot;
     if (fret == 12)
       html += symDot + symDot;
    }
   html += "</td>";
   sw -= fretDecrease;
  }

 html += "</tr>";
 return html;
}

function GenBass(chord, offset, key) // chord pattern index, offset C=0, Key object
{
 var html;

 html = "<table>";

 html += GenBassString(chord, offset, 3, key);
 html += GenBassString(chord, offset, 2, key);
 html += GenBassString(chord, offset, 1, key);
 html += GenBassString(chord, offset, 0, key);

 html += GenBassMarks();

 html += "</table>";
  
 return html;
}

function GenBassScale(key)
{
 var html;
 var midiBase = GetBaseMidiNote(key.Offset);

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"f\");'>" + symFwd + "</td>";

 html += GenScaleInfo(key);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenBassStringScale(3, key, key.Notes); // return TRs
 html += GenBassStringScale(2, key, key.Notes);
 html += GenBassStringScale(1, key, key.Notes);
 html += GenBassStringScale(0, key, key.Notes);
 html += GenBassMarks();

 html += "</table></td></tr></table>";

 return html;
}

function GenBassOtherScale(key, notes)
{
 var html;
 var midiBase = GetBaseMidiNote(key.Offset);

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrScales[m_CurrentScale].ScaleName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"f\");'>" + symFwd + "</td>";

 html += GenOtherScaleInfo(key, notes);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenBassStringScale(3, key, notes);
 html += GenBassStringScale(2, key, notes);
 html += GenBassStringScale(1, key, notes);
 html += GenBassStringScale(0, key, notes);
 html += GenBassMarks();

 html += "</table></td></tr></table>";

 return html;
}

function GenBassPlayBoard()
{
 var i, k, html;
 var midiNum, midi, sw;
 var td, w;
 
 html = "<table>";
 
 m_mapPlayInst = new Map();

 sw = fretStartSize;
 for (i=m_arrInstruments[m_Bass].Strings - 1; i>=0; i--)
  {
   html += "<tr>";
   for (k=0; k<m_arrInstruments[m_Bass].Frets; k++)
    {
     midiNum = m_arrBass[i][k]; // get midi note of string and fret
     midi = m_mapMidiNotes.get(midiNum);
     if (k == 0) // before the nut
       w = fretBeforeNut;   // 25 pixels
     else  
       w = sw;
     if (k >= m_CurrentBassCapo)
      {
       td = "tdPI_" + i + "_" + k;
       html += "<td class='fretPlay' style='width:" + w + "vw;' id='" + td + "' onclick='ComposePlayNoteSound(new PlayNote(" + midi.toString() + ", null));'>";
       html += NoteText(midi.Offset) + midi.Octave;
       if (m_mapPlayInst.has(midiNum) == true)
         m_mapPlayInst.get(midiNum).push(td);
       else
         m_mapPlayInst.set(midiNum, [td]);  // so the map will contain keys of midi numbers and the value is an array of TD id's that need to be set if the note comes up
      }
     else
      {
       html += "<td class='fretPlay' style='width:" + w.toString() + "vw; background-color:lightgray;'>";
      }  
     html += "</td>";
     sw -=  fretDecrease; // 1 pixel
    }
   html += "</tr>";
  }
 html += GenBassMarks();
 html += "</table>"; 

 document.getElementById("divPlayInst").innerHTML = html;
}

////////////////////////////////////////////////
//             M a n d o l i n 
////////////////////////////////////////////////

// generate mandolin fretboard
// returns a open chord fingering letter I,M,R,P or O, X based on string and fret
// m_arrChordPatterns has been prepared that contain the fingering

function GenMandolinStringElement(chord, offset, wstr, fret) // chord = chord pattern index, offset c=0, wstr is string #, fret # nut is 0
{
 var i, k, capo, off;

 capo = m_CurrentMandolinCapo;
 off = offset - capo;  // so if offset was c# and capo == 1, off will be set to "c", the pattern that will play a c# chord if capo is on fret 1
 if (off < 0)
   off += 12;


 for (i=0; i<m_arrChordPatterns[chord].PatternMandolin.length; i++) // go thru the placements
  {
   if (m_arrChordPatterns[chord].PatternMandolin[i].Offset == off) // see if offset is present C = 0
    {
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Index.length; k++) // go thru Index finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Index[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Index[k].Fret + capo == fret)
         return m_arrFingering[0]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Middle.length; k++) // go thru middle finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Middle[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Middle[k].Fret + capo == fret)
         return m_arrFingering[1]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Ring.length; k++) // go thru ring finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Ring[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Ring[k].Fret + capo == fret)
         return m_arrFingering[2]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Pinky.length; k++) // go thru pinky finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Pinky[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Pinky[k].Fret + capo == fret)
         return m_arrFingering[3]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Open.length; k++) // go thru open string list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Open[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Open[k].Fret + capo == fret)
         return "O"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].NoPlay.length; k++) // go thru no play finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].NoPlay[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].NoPlay[k].Fret + capo == fret)
         return "X"; 
      }
    }
  }
 return "";
}

// return barre chord fingering I,M,R,P or X based on string and fret
// each barre pattern, E and A types were prepared.
// the Offsets array for each contains the offset to the barre pattern fingering array
// the offset gives the location of the barre chord for the passed offset. For the A and Am pattern C = 0 would return 2 which is the A pattern up the 3rd fret.
// the reason C is not 3 is because the open A is not included in the fingering, only barre chords are present.  

function GenMandolinBarreStringElement(chord, offset, wstr, fret) // ChordPatteren index, offset C=0, String # (low E is 0), fret # (nut is 0)
{ 
 // for barre need to not return fingerings for open A and open E
 var i, k, fo;

 for (i=0; i<m_arrMandolinBarre.length; i++)
  {
   if (chord == m_arrMandolinBarre[i].CP)
    {
     fo =m_arrMandolinBarre[i].Offsets[offset];
     for (k=0; k<m_arrMandolinBarre[i].Index[fo].length; k++)
      {
       if (m_arrMandolinBarre[i].Index[fo][k].Str == wstr && m_arrMandolinBarre[i].Index[fo][k].Fret == fret)
         return m_arrFingering[0];
      }
     for (k=0; k<m_arrMandolinBarre[i].Middle[fo].length; k++)
      {
       if (m_arrMandolinBarre[i].Middle[fo][k].Str == wstr && m_arrMandolinBarre[i].Middle[fo][k].Fret == fret)
         return m_arrFingering[1];
      }
     for (k=0; k<m_arrMandolinBarre[i].Ring[fo].length; k++)
      {
       if (m_arrMandolinBarre[i].Ring[fo][k].Str == wstr && m_arrMandolinBarre[i].Ring[fo][k].Fret == fret)
         return m_arrFingering[2];
      }
     for (k=0; k<m_arrMandolinBarre[i].Pinky[fo].length; k++)
      {
       if (m_arrMandolinBarre[i].Pinky[fo][k].Str == wstr && m_arrMandolinBarre[i].Pinky[fo][k].Fret == fret)
         return m_arrFingering[3];
      }
     for (k=0; k<m_arrMandolinBarre[i].NoPlay[fo].length; k++)
      {
       if (m_arrMandolinBarre[i].NoPlay[fo][k].Str == wstr && m_arrMandolinBarre[i].NoPlay[fo][k].Fret == fret)
         return "X";
      }
    }
  }
 return "";
}

// Show Note gets the ShowNote property of the BarreIndex object for barre chord fingerings
// the Offset lookup system is the same as GenMandolinBarreStringElement above

function GenMandolinBarreShowNote(chord, offset, wstr, fret) // chord (index to m_arrChordPattern), offset c=0, string (low = 0), fret #
{ 
 var i, k, fo;
 // for barre need to not return fingerings for open A and open E
 for (i=0; i<m_arrMandolinBarre.length; i++)
  {
   if (chord == m_arrMandolinBarre[i].CP)
    {
     fo = m_arrMandolinBarre[i].Offsets[offset]; // if offset = 0, C, fo = 2
     for (k=0; k<m_arrMandolinBarre[i].Index[fo].length; k++)
      {
       if (m_arrMandolinBarre[i].Index[fo][k].Str == wstr && m_arrMandolinBarre[i].Index[fo][k].Fret == fret)
         return m_arrMandolinBarre[i].Index[fo][k].ShowNote;
      }
    }
  }
 return 1;
}

function GenMandolinNoData(chord, offset) // returns true if no chord data is found 
{
 var i;

 for (i=0; i<m_arrChordPatterns[chord].PatternMandolin.length; i++) 
  {
   if (m_arrChordPatterns[chord].PatternMandolin[i].Offset == offset) // see if offset is present C = 0
     return false;
  }
 for (i=0; i<m_arrMandolinBarre.length; i++)
  {
   if (m_arrMandolinBarre[i].CP == chord)
     return false;
  }
 return true;
}

// generate a TR html for a mandolin string for a specific chord

function GenMandolinString(chord, offset, wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var barre, open, barreShowNote;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; // 40 pixels
 var noData;
 var w;
 var pn;

 for (fret=0; fret<m_arrInstruments[m_Mandolin].Frets; fret++)
  {
   midi = m_arrMandolin[wstr][fret]; // get midi note of string and fret
   
   if (fret == 0) // before the nut
     w = fretBeforeNut;   // 25 pixels
   else  
     w = sw;

   pn = GetPlayNote(midi);

   if (fret >= m_CurrentMandolinCapo)
    {
     html += "<td class='fretString' onclick='PlayNoteSound(new PlayNote(" + midi.toString() + ", " + Quotes(pn.Text) + "));'>";

     noData = GenMandolinNoData(chord, offset);
     open = GenMandolinStringElement(chord, offset, wstr, fret);
     barre = GenMandolinBarreStringElement(chord, offset, wstr, fret);
     barreShowNote = GenMandolinBarreShowNote(chord, offset, wstr, fret);

     html += GenStringCell(chord, key, offset, midi, w, open, barre, barreShowNote, noData, m_CurrentMandolinTuning);
    }
   else
    {
     html += "<td class='fretString' style='width:" + w.toString() + "vw; background-color:lightgray;'>";
    }
   html += "</td>";
   sw -=  fretDecrease; // 1 pixel
  }
 html += "</tr>";
 return html;
}

function GenMandolinStringScale(wstr, key, notes) // string # and array of Note objects
{
var midi, midiNum;
 var bg, fg;
 var sn;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; //vw units about 40 pixels on a 1920 display, this is the size of area between the nut and fret 1
 var w, i, keyNdx;
 var note, text, noteText;

 for (fret=0; fret<m_arrInstruments[m_Mandolin].Frets; fret++)
  {
   midiNum = m_arrMandolin[wstr][fret];  // get midi # note of string and fret
   midi = m_mapMidiNotes.get(midiNum); // get Midi object
   note = null;
   sn = -1;
   for(i=0; i<notes.length; i++)
    {
     if (midi.Offset == notes[i].Offset)
      {
       sn = i;
       note = notes[i];
       keyNdx = key.NoteIndex(note);
       if (keyNdx >= 0)
         bg = m_arrGradientBlueGreen[keyNdx];
       else
         bg = blueNote;
       fg = "#000044";
       text = note.Text;
      }
    }
   if (note == null)
    {
     text = "";
     bg = "#CCCCCC";
     fg = "white";
    }

   if (text == "")
     noteText = NoteText(midi);
   else
     noteText = text;

   if (fret == 0)        // before the nut
     w = fretBeforeNut;  // 25 pixels
   else  
     w = sw;

   if (fret >= m_CurrentMandolinCapo)
    {
     html += "<td class='fretString' style='color:" + fg + "; background-color:" + bg + ";' onclick='PlayNoteSound(new PlayNote(" + midiNum.toString() + ", " + Quotes(noteText) + "));'>";
     html += "<div class='fretCell' style='width:" + w.toString() + "vw;'>";
     html += text;
     if (sn >= 0)
       html += "<br><div class='fretCellInfo'>" + (sn + 1).toString() + "</div>";
     html += "</div>";
    }
   else
    {
     html += "<td class='fretString' style='width:" + w.toString() + "vw; color:" + fg + "; background-color:lightgray;'>";
    }
   html += "</td>";
   sw -= fretDecrease; // subtract about a pixel on 1920 monitor
  }
 html += "</tr>";
 return html;}

function GenMandolinMarks()
{
 var html = "<tr>";
 var fret, w;
 var sw = fretMarkStart; // 30 pixels, have to slide this over a bit to line up the dots like a fretboard

 for (fret=0; fret<m_arrInstruments[m_Mandolin].Frets; fret++)
  {
   if (fret == 0) // before the nut
     w = fretMarkBeforeNut;   // 15 pixels
   else  
     w = sw;
   html += "<td class='fretMark' style='width:" + w.toString() + "vw;'>";
   if (m_CurrentMandolinCapo > 0 && m_CurrentMandolinCapo == fret)
     html += "Capo";
   else
    {
     if (fret == 0)
       html += "Nut";
     if (fret == 5 || fret ==7 || fret == 10 || fret == 15) 
       html += symDot;
     if (fret == 12)
       html += symDot + symDot;
    }
   html += "</td>";
   sw -= fretDecrease;
  }

 html += "</tr>";
 return html;
}

function GenMandolin(chord, offset, key) // chord pattern index, offset C=0, Key object
{
 var html;

 html = "<table>";

 html += GenMandolinString(chord, offset, 3, key);
 html += GenMandolinString(chord, offset, 2, key);
 html += GenMandolinString(chord, offset, 1, key);
 html += GenMandolinString(chord, offset, 0, key);
 html += GenMandolinMarks();

 html += "</table>";
  
 return html;
}

function GenMandolinScale(key)
{
 var html;
 var midiBase = GetBaseMidiNote(key.Offset);

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"f\");'>" + symFwd + "</td>";

 html += GenScaleInfo(key);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenMandolinStringScale(3, key, key.Notes);
 html += GenMandolinStringScale(2, key, key.Notes);
 html += GenMandolinStringScale(1, key, key.Notes);
 html += GenMandolinStringScale(0, key, key.Notes);
 html += GenMandolinMarks();

 html += "</table></td></tr></table>";

 return html;
}

function GenMandolinOtherScale(key, notes)
{
 var html;
 var midiBase = GetBaseMidiNote(key.Offset);

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrScales[m_CurrentScale].ScaleName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"f\");'>" + symFwd + "</td>";

 html += GenOtherScaleInfo(key, notes);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenMandolinStringScale(3, key, notes);
 html += GenMandolinStringScale(2, key, notes);
 html += GenMandolinStringScale(1, key, notes);
 html += GenMandolinStringScale(0, key, notes);
 html += GenMandolinMarks();

 html += "</table></td></tr></table>";

 return html;
}

function GenMandolinPlayBoard()
{
 var i, k, html;
 var midi, midiNum, sw;
 var td, w;
 
 html = "<table>";
 
 m_mapPlayInst = new Map();

 sw = fretStartSize;
 for (i=m_arrInstruments[m_Mandolin].Strings - 1; i>=0; i--)
  {
   html += "<tr>";
   for (k=0; k<m_arrInstruments[m_Mandolin].Frets; k++)
    {
     midiNum = m_arrMandolin[i][k]; // get midi note of string and fret
     midi = m_mapMidiNotes.get(midiNum);
     if (k == 0) // before the nut
       w = fretBeforeNut;   // 25 pixels
     else  
       w = sw;
     if (k >= m_CurrentMandolinCapo)
      {
       td = "tdPI_" + i + "_" + k;
       html += "<td class='fretPlay' style='width:" + w + "vw;' id='" + td + "' onclick='ComposePlayNoteSound(new PlayNote(" + midi.toString() + ", null));'>";
       html += NoteText(midi.Offset + midi.Octave);
       if (m_mapPlayInst.has(midiNum) == true)
         m_mapPlayInst.get(midiNum).push(td);
       else
         m_mapPlayInst.set(midiNum, [td]);  // so the map will contain keys of midi numbers and the value is an array of TD id's that need to be set if the note comes up
      }
     else
      {
       html += "<td class='fretPlay' style='width:" + w.toString() + "vw; background-color:lightgray;'>";
      }  
     html += "</td>";
     sw -=  fretDecrease; // 1 pixel
    }
   html += "</tr>";
  }
 html += GenMandolinMarks();
 html += "</table>"; 

 document.getElementById("divPlayInst").innerHTML = html;
}
////////////////////////////////////////////////
//                 U k u l e l e     
////////////////////////////////////////////////

// generate ukulele fretboard
// returns a open chord fingering letter I,M,R,P or O, X based on string and fret
// m_arrChordPatterns has been prepared that contain the fingering

function GenUkuleleStringElement(chord, offset, wstr, fret) // chord = chord pattern index, offset c=0, wstr is string #, fret # nut is 0
{
 var i, k, capo, off;

 capo = m_CurrentUkuleleCapo;
 off = offset - capo;  // so if offset was c# and capo == 1, off will be set to "c", the pattern that will play a c# chord if capo is on fret 1
 if (off < 0)
   off += 12;

 for (i=0; i<m_arrChordPatterns[chord].PatternUkulele.length; i++) // go thru the placements
  {
   if (m_arrChordPatterns[chord].PatternUkulele[i].Offset == off) // see if offset is present C = 0
    {
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Index.length; k++) // go thru Index finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Index[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Index[k].Fret + capo == fret)
         return m_arrFingering[0]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Middle.length; k++) // go thru middle finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Middle[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Middle[k].Fret + capo == fret)
         return m_arrFingering[1]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Ring.length; k++) // go thru ring finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Ring[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Ring[k].Fret + capo == fret)
         return m_arrFingering[2]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Pinky.length; k++) // go thru pinky finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Pinky[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Pinky[k].Fret + capo == fret)
         return m_arrFingering[3]; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Open.length; k++) // go thru open string list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Open[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Open[k].Fret + capo == fret)
         return "O"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].NoPlay.length; k++) // go thru no play finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].NoPlay[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].NoPlay[k].Fret + capo == fret)
         return "X"; 
      }
    }
  }
 return "";
}

// return barre chord fingering I,M,R,P or X based on string and fret
// each barre pattern, E and A types were prepared.
// the Offsets array for each contains the offset to the barre pattern fingering array
// the offset gives the location of the barre chord for the passed offset. For the A and Am pattern C = 0 would return 2 which is the A pattern up the 3rd fret.
// the reason C is not 3 is because the open A is not included in the fingering, only barre chords are present.  

function GenUkuleleBarreStringElement(chord, offset, wstr, fret) // ChordPatteren index, offset C=0, String # (low E is 0), fret # (nut is 0)
{ 
 var i, k, fo;

 for (i=0; i<m_arrUkuleleBarre.length; i++)
  {
   if (m_arrUkuleleBarre[i].CP == chord)
    {
     fo = m_arrUkuleleBarre[i].Offsets[offset];
     for (k=0; k<m_arrUkuleleBarre[i].Index[fo].length; k++)
      {
       if (m_arrUkuleleBarre[i].Index[fo][k].Str == wstr && m_arrUkuleleBarre[i].Index[fo][k].Fret == fret)
         return m_arrFingering[0];
      }
     for (k=0; k<m_arrUkuleleBarre[i].Middle[fo].length; k++)
      {
       if (m_arrUkuleleBarre[i].Middle[fo][k].Str == wstr && m_arrUkuleleBarre[i].Middle[fo][k].Fret == fret)
         return m_arrFingering[1];
      }
     for (k=0; k<m_arrUkuleleBarre[i].Ring[fo].length; k++)
      {
       if (m_arrUkuleleBarre[i].Ring[fo][k].Str == wstr && m_arrUkuleleBarre[i].Ring[fo][k].Fret == fret)
         return m_arrFingering[2];
      }
     for (k=0; k<m_arrUkuleleBarre[i].Pinky[fo].length; k++)
      {
       if (m_arrUkuleleBarre[i].Pinky[fo][k].Str == wstr && m_arrUkuleleBarre[i].Pinky[fo][k].Fret == fret)
         return m_arrFingering[3];
      }
     for (k=0; k<m_arrUkuleleBarre[i].NoPlay[fo].length; k++)
      {
       if (m_arrUkuleleBarre[i].NoPlay[fo][k].Str == wstr && m_arrUkuleleBarre[i].NoPlay[fo][k].Fret == fret)
         return "X";
      }
    }
  }
 return "";
}

// Show Note gets the ShowNote property of the BarreIndex object for barre chord fingerings
// the Offset lookup system is the same as GenUkuleleBarreStringElement above

function GenUkuleleBarreShowNote(chord, offset, wstr, fret) // chord (index to m_arrChordPattern), offset c=0, string (low = 0), fret #
{ 
 var i, k, fo;

 for (i=0; i<m_arrUkuleleBarre.length; i++)
  {
   if (m_arrUkuleleBarre[i].CP == chord)
    {
     fo = m_arrUkuleleBarre[i].Offsets[offset]; // if offset = 0, C, fo = 2
     for (k=0; k<m_arrUkuleleBarre[i].Index[fo].length; k++)
      {
       if (m_arrUkuleleBarre[i].Index[fo][k].Str == wstr && m_arrUkuleleBarre[i].Index[fo][k].Fret == fret)
         return m_arrUkuleleBarre[i].Index[fo][k].ShowNote;
      }
    }
  }
 return 1;
}

function GenUkuleleNoData(chord, offset) // returns true if no chord data is found 
{
 var i;

 for (i=0; i<m_arrChordPatterns[chord].PatternUkulele.length; i++) 
  {
   if (m_arrChordPatterns[chord].PatternUkulele[i].Offset == offset) // see if offset is present C = 0
     return false;
  }
 for (i=0; i<m_arrUkuleleBarre.length; i++)
  {
   if (m_arrUkuleleBarre[i].CP == chord)
     return false;
  }
 return true;
}

// generate a TR html for a ukulele string for a specific chord

function GenUkuleleString(chord, offset, wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var barre, open, barreShowNote;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; // 40 pixels
 var noData;
 var w;
 var pn;

 for (fret=0; fret<m_arrInstruments[m_Ukulele].Frets; fret++)
  {
   midi = m_arrUkulele[wstr][fret]; // get midi note of string and fret

   if (fret == 0) // before the nut
     w = fretBeforeNut;   // 25 pixels
   else  
     w = sw;

   pn = GetPlayNote(midi);

   if (fret >= m_CurrentUkuleleCapo)
    {
     html += "<td class='fretString' onclick='PlayNoteSound(new PlayNote(" + midi.toString() + ", " + Quotes(pn.Text) + "));'>";

     noData = GenUkuleleNoData(chord, offset);
     open = GenUkuleleStringElement(chord, offset, wstr, fret);
     barre = GenUkuleleBarreStringElement(chord, offset, wstr, fret);
     barreShowNote = GenUkuleleBarreShowNote(chord, offset, wstr, fret);

     html += GenStringCell(chord, key, offset, midi, w, open, barre, barreShowNote, noData, m_CurrentUkuleleTuning);
    }
   else
    {
     html += "<td class='fretString' style='width:" + w.toString() + "vw; background-color:lightgray;'>";
    }
   html += "</td>";
   sw -=  fretDecrease; // 1 pixel
  }
 html += "</tr>";
 return html;
}

function GenUkuleleStringScale(wstr, key, notes) // string #, array of Note objects
{
var midi, midiNum;
 var bg, fg;
 var sn;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; //vw units about 40 pixels on a 1920 display, this is the size of area between the nut and fret 1
 var w, i, keyNdx;
 var note, text, noteText;

 for (fret=0; fret<m_arrInstruments[m_Ukulele].Frets; fret++)
  {
   midiNum = m_arrUkulele[wstr][fret];  // get midi # note of string and fret
   midi = m_mapMidiNotes.get(midiNum); // get Midi object
   note = null;
   sn = -1;
   for(i=0; i<notes.length; i++)
    {
     if (midi.Offset == notes[i].Offset)
      {
       sn = i;
       note = notes[i];
       keyNdx = key.NoteIndex(note);
       if (keyNdx >= 0)
         bg = m_arrGradientBlueGreen[keyNdx];
       else
         bg = blueNote;
       fg = "#000044";
       text = note.Text;
      }
    }
   if (note == null)
    {
     text = "";
     bg = "#CCCCCC";
     fg = "white";
    }

   if (text == "")
     noteText = NoteText(midiNum);
   else
     noteText = text;

   if (fret == 0)        // before the nut
     w = fretBeforeNut;  // 25 pixels
   else  
     w = sw;

   if (fret >= m_CurrentUkuleleCapo)
    {
     html += "<td class='fretString' style='color:" + fg + "; background-color:" + bg + ";' onclick='PlayNoteSound(new PlayNote(" + midiNum.toString() + ", " + Quotes(noteText) + "));'>";
     html += "<div class='fretCell' style='width:" + w.toString() + "vw;'>";
     html += text;
     if (sn >= 0)
       html += "<br><div class='fretCellInfo'>" + (sn + 1).toString() + "</div>";
     html += "</div>";
    }
   else
    {
     html += "<td class='fretString' style='width:" + w.toString() + "vw; color:" + fg + "; background-color:lightgray;'>";
    }
   html += "</td>";
   sw -= fretDecrease; // subtract about a pixel on 1920 monitor
  }
 html += "</tr>";
 return html;
}

function GenUkuleleMarks()
{
 var html = "<tr>";
 var fret, w;
 var sw = fretMarkStart; // 30 pixels, have to slide this over a bit to line up the dots like a fretboard

 for (fret=0; fret<m_arrInstruments[m_Ukulele].Frets; fret++)
  {
   if (fret == 0) // before the nut
     w = fretMarkBeforeNut;   // 15 pixels
   else  
     w = sw;
   html += "<td class='fretMark' style='width:" + w.toString() + "vw;'>";
   if (m_CurrentUkuleleCapo > 0 && m_CurrentUkuleleCapo == fret)
     html += "Capo";
   else
    {
     if (fret == 0)
       html += "Nut";
     if (fret == 3 || fret == 5 || fret ==7 || fret == 10) 
       html += symDot;
     if (fret == 12)
       html += symDot + symDot;
    }
   html += "</td>";
   sw -= fretDecrease;
  }

 html += "</tr>";
 return html;
}

function GenUkulele(chord, offset, key) // chord pattern index, offset C=0, Key object
{
 var html;

 html = "<table>";

 html += GenUkuleleString(chord, offset, 3, key);
 html += GenUkuleleString(chord, offset, 2, key);
 html += GenUkuleleString(chord, offset, 1, key);
 html += GenUkuleleString(chord, offset, 0, key);
 html += GenUkuleleMarks();

 html += "</table>";
  
 return html;
}

function GenUkuleleScale(key)
{
 var html;
 var midiBase = GetBaseMidiNote(key.Offset);

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"f\");'>" + symFwd + "</td>";

 html += GenScaleInfo(key);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenUkuleleStringScale(3, key, key.Notes);
 html += GenUkuleleStringScale(2, key, key.Notes);
 html += GenUkuleleStringScale(1, key, key.Notes);
 html += GenUkuleleStringScale(0, key, key.Notes);

 html += GenUkuleleMarks();

 html += "</table></td></tr></table>";

 return html;
}

function GenUkuleleOtherScale(key, notes)
{
 var html;
 var midiBase = GetBaseMidiNote(key.Offset);

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrScales[m_CurrentScale].ScaleName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"f\");'>" + symFwd + "</td>";

 html += GenOtherScaleInfo(key, notes);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenUkuleleStringScale(3, key, notes);
 html += GenUkuleleStringScale(2, key, notes);
 html += GenUkuleleStringScale(1, key, notes);
 html += GenUkuleleStringScale(0, key, notes);
 html += GenUkuleleMarks();

 html += "</table></td></tr></table>";

 return html;
}

function GenUkulelePlayBoard()
{
 var i, k, html;
 var midi, midiNum, sw;
 var td, w;
 
 html = "<table>";
 
 m_mapPlayInst = new Map();

 sw = fretStartSize;
 for (i=m_arrInstruments[m_Ukulele].Strings - 1; i>=0; i--)
  {
   html += "<tr>";
   for (k=0; k<m_arrInstruments[m_Ukulele].Frets; k++)
    {
     midiNum = m_arrUkulele[i][k]; // get midi note of string and fret
     midi = m_mapMidiNotes.get(midiNum);
     if (k == 0) // before the nut
       w = fretBeforeNut;   // 25 pixels
     else  
       w = sw;
     if (k >= m_CurrentUkuleleCapo)
      {
       td = "tdPI_" + i + "_" + k;
       html += "<td class='fretPlay' style='width:" + w + "vw;' id='" + td + "' onclick='ComposePlayNoteSound(new PlayNote(" + midi.toString() + ", null));'>";
       html += NoteText(midi.Offset) + midi.Octave;
       if (m_mapPlayInst.has(midiNum) == true)
         m_mapPlayInst.get(midiNum).push(td);
       else
         m_mapPlayInst.set(midiNum, [td]);  // so the map will contain keys of midi numbers and the value is an array of TD id's that need to be set if the note comes up
      }
     else
      {
       html += "<td class='fretPlay' style='width:" + w.toString() + "vw; background-color:lightgray;'>";
      }  
     html += "</td>";
     sw -=  fretDecrease; // 1 pixel
    }
   html += "</tr>";
  }
 html += GenUkuleleMarks();
 html += "</table>"; 

 document.getElementById("divPlayInst").innerHTML = html;
}

////////////////////////////////////////////////
//            K e y b o a r d     
////////////////////////////////////////////////

function GenPianoChordNote(cssName, key, midiNote, arrMidiNotes, notes)
{
 var html;
 var chordSeq;
 var fg;
 var bg;
 var i;
 var midi;
 var text;
 var note;

 midi = m_mapMidiNotes.get(midiNote);

 chordSeq = -1;
 for (i=0; i<arrMidiNotes.length; i++)
  {
   if (midiNote == arrMidiNotes[i])
     chordSeq = i;
  }

 if (chordSeq >=0)
  {
   note = null;
   for (i=0; i<notes.length; i++)
    {
     if (midi.Offset == notes[i].Offset)
       note = notes[i];
    }
   if (note != null)
    {
     i = key.NoteIndex(note);
     if (i >= 0)        
      bg = m_arrGradientBlueGreen[i];
     else
      bg = blueNote;
     text = note.Text;
    }
   else 
    {
     bg = blueNote;
     text = NoteText(midi.Offset);
    }
   fg = "black";

   html = "<div class='" + cssName + "' style='color:" + fg + "; background-color:" + bg + ";'>";
   
   i = text.indexOf("/");
   if (i>0)
     text = text.substring(0,i) + "<br>" + text.substring(i+1);

   html += text;
   html += "</div>";
  }
 else
  {
   html = ""; // don't show a note
  }
 return html;
}

//   c#  d#     f#  g#  a#    c#   d#     f#  g#  a#
// c   d   e  f   g   a   b  c   d   e  f   g   a   b     
// 0 1 2 3 4 5  6 7 8 9 1 1  1 1 1 1 1  1 1 1 2 2 2 2
//                      0 1  2 3 4 5 6  7 8 9 0 1 2 3

function GenPianoChord(octaves, chord, offset, key) // return divs of piano keys.  # of octaves to show, index to chord pattern array, root note offset, key object
{                                                   
 var pat = m_arrChordPatterns[chord];
 var html;
 var k, i;     
 var x, w;     // x position of each octave set of keys
 var o;
 var wMidi, sMidi, midi;
 var arrChordNotes = [];
 var found, pn;

 wMidi = 48; //  c3 - starting note

 sMidi = wMidi + key.Offset;  // step up to key's starting note, 

 found = false;
 for(i=0; i<m_Key.Offsets.length; i++)
  {
   if (m_Key.Offsets[i] == offset) // go thru the key's offsets until the current chord root note offset is found
     found = true;
   if (found == false)
     sMidi += m_arrModes[m_CurrentMode].Sequences[i]; // bump the midi note # up until the offset is found
  }

 // sMidi will be the chord's root note up from the mode's starting chord root

 for(i=0; i<pat.Pitches.length; i++)
  {
   arrChordNotes[i] = sMidi + pat.Pitches[i];
  }

 html = "<div style='position:relative; width:" + octaves * pianoWhiteWidth * 7 + "vw; height:" + pianoWhiteHeight + "vw;'>";

 x = 0;  // starting x position

 for (o=0; o<octaves; o++)
  {
   w = x;               // div x position
   midi = wMidi;
   for (k=0; k<7; k++)  // 7 white keys from C to B
    {
     pn = GetPlayNote(midi);
     html += "<div class='pianoWhite' style='left:" + w.toString() + "vw;' onclick='PlayNoteSound(new PlayNote(" + midi.toString() +", " + Quotes(pn.Text) + "));'>";
     html += GenPianoChordNote("pianoWhiteText", key, midi, arrChordNotes, key.Notes );
     html += "</div>";
     if (k==2 || k==6)  // E or B  key ??
      {
       midi += 1; // next white key
      }
     else
      { 
       midi += 2; // rest of the white keys are up 2
      }
     w += pianoWhiteWidth;
    }
   w = x + pianoWhiteWidth - (pianoBlackWidth / 2);  // center black keys in middle of 1st white key
   midi = wMidi + 1;  // starting midi note of black keys
   for (k=0; k<5; k++) // 5 black keys
    {
     pn = GetPlayNote(midi);
     html += "<div class='pianoBlack' style='left:" + w.toString() + "vw;' onclick='PlayNoteSound(new PlayNote(" + midi.toString() + ", " + Quotes(pn.Text) + "));'>";
     html += GenPianoChordNote("pianoBlackText", key, midi, arrChordNotes, key.Notes);
     html += "</div>"; 
     if (k==1 || k==4) // is the next key an f# or c#
      {
       w += pianoWhiteWidth * 2;  // move next f# or c# over 2 white key widths
       midi += 3;                   // note offset is bumped 3
      }
     else
      {
       w += pianoWhiteWidth;   // these keys are next to each other  
       midi += 2;               
      }
    }
   x += pianoWhiteWidth * 7; // next octive set x location
   wMidi += 12;
  }
 
 html += "</div>";

 return html;
}

function GenPianoScaleKeys(octaves, key, arrScaleNotes) // return divs of piano keys. ocatives is number of octaves to draw
{
 var html;
 var k;     
 var x, w;     // x position of each octave set of keys
 var o;
 var wMidi, midi, pn;

 wMidi = 48; // c3 - starting note

 html = "<div style='position:relative; width:" + octaves * pianoWhiteWidth * 7 + "vw; height:" + pianoWhiteHeight + "vw;'>";

 x = 0;  // starting x position

 for (o=0; o<octaves; o++)
  {
   w = x;               // div x position
   midi = wMidi;
   for (k=0; k<7; k++)  // 7 white keys from C to B
    {
     pn = GetPlayNote(midi);
     html += "<div class='pianoWhite' style='left:" + w.toString() + "vw;' onclick='PlayNoteSound(new PlayNote(" + midi.toString() +", " + Quotes(pn.Text) + "));'>";
     html += GenPianoChordNote("pianoWhiteText", key, midi, arrScaleNotes, key.Notes);
     html += "</div>";
     if (k==2 || k==6)  // E or B  key ??
      {
       midi += 1; // next white key
      }
     else
      { 
       midi += 2; // rest of the white keys are up 2
      }
     w += pianoWhiteWidth;
    }
   w = x + pianoWhiteWidth - (pianoBlackWidth / 2);  // center black keys in middle of 1st white key
   midi = wMidi + 1;  // starting midi note of black keys
   for (k=0; k<5; k++) // 5 black keys
    {
     pn = GetPlayNote(midi);
     html += "<div class='pianoBlack' style='left:" + w.toString() + "vw;' onclick='PlayNoteSound(new PlayNote(" + midi.toString() +", " + Quotes(pn.Text) + "));'>";
     html += GenPianoChordNote("pianoBlackText", key, midi, arrScaleNotes, key.Notes);
     html += "</div>"; 
     if (k==1 || k==4) // is the next key an f# or c#
      {
       w += pianoWhiteWidth * 2;  // move next f# or c# over 2 white key widths
       midi += 3;                 // note offset is bumped 3
      }
     else
      {
       w += pianoWhiteWidth;   // these keys are next to each other  
       midi += 2;               
      }
    }
   x += pianoWhiteWidth * 7; // next octive set x location
   wMidi += 12;
  }
 
 html += "</div>";

 return html;
}

function GenPianoOtherScaleKeys(octaves, key, arrScaleNotes, notes) // return divs of piano keys. ocatives is number of octaves to draw
{
 var html;
 var k;     
 var x, w;     // x position of each octave set of keys
 var o;
 var wMidi, midi, pn;

 wMidi = 48; // c3 - starting note

 html = "<div style='position:relative; width:" + octaves * pianoWhiteWidth * 7 + "vw; height:" + pianoWhiteHeight + "vw;'>";

 x = 0;  // starting x position

 for (o=0; o<octaves; o++)
  {
   w = x;               // div x position
   midi = wMidi;
   for (k=0; k<7; k++)  // 7 white keys from C to B
    {
     pn = GetPlayNote(midi);
     html += "<div class='pianoWhite' style='left:" + w.toString() + "vw;' onclick='PlayNoteSound(new PlayNote(" + midi.toString() +", " + Quotes(pn.Text) + "));'>";
     html += GenPianoChordNote("pianoWhiteText", key, midi, arrScaleNotes, notes);
     html += "</div>";
     if (k==2 || k==6)  // E or B  key ??
      {
       midi += 1; // next white key
      }
     else
      { 
       midi += 2; // rest of the white keys are up 2
      }
     w += pianoWhiteWidth;
    }
   w = x + pianoWhiteWidth - (pianoBlackWidth / 2);  // center black keys in middle of 1st white key
   midi = wMidi + 1;  // starting midi note of black keys
   for (k=0; k<5; k++) // 5 black keys
    {
     pn = GetPlayNote(midi);
     html += "<div class='pianoBlack' style='left:" + w.toString() + "vw;' onclick='PlayNoteSound(new PlayNote(" + midi.toString() +", " + Quotes(pn.Text) + "));'>";
     html += GenPianoChordNote("pianoBlackText", key, midi, arrScaleNotes, notes);
     html += "</div>"; 
     if (k==1 || k==4) // is the next key an f# or c#
      {
       w += pianoWhiteWidth * 2;  // move next f# or c# over 2 white key widths
       midi += 3;                 // note offset is bumped 3
      }
     else
      {
       w += pianoWhiteWidth;   // these keys are next to each other  
       midi += 2;               
      }
    }
   x += pianoWhiteWidth * 7; // next octive set x location
   wMidi += 12;
  }
 
 html += "</div>";

 return html;
}


function GenPianoScale(key, mode)
{
 var html;
 var arrScaleNotes = [];
 var wMidi, midi, midiBase;
 var i;

 wMidi = 48;                    // keyboard's starting midi note c3
 midiBase = wMidi + key.Offset; // for playing scale
 midi = wMidi + key.Offset;     // scale's starting midi note

 for (i=0; i<m_arrModes[mode].Sequences.length; i++)
  {
   arrScaleNotes[i] = midi;
   midi += m_arrModes[mode].Sequences[i];
  }

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", -1), \"f\");'>" + symFwd + "</td>";

 html += GenScaleInfo(key);

 html += "</tr></table></tr></td><tr><td>";

 html += GenPianoScaleKeys(2, key, arrScaleNotes);

 html += "</td></tr></table>";

 return html; 
}

function GenPianoOtherScale(key, notes) // Key object, array of Note objects
{
 var html;
 var arrScaleNotes = [];
 var wMidi, midi, midiBase;
 var i;

 wMidi = 48;                     // keyboard's starting midi note c3
 midiBase = wMidi + key.Offset;  // for playing scale
 midi = wMidi + key.Offset;      // scale's starting midi note

 for (i=0; i<m_arrScales[m_CurrentScale].Sequences.length; i++)
  {
   arrScaleNotes[i] = midi;
   midi += m_arrScales[m_CurrentScale].Sequences[i];
  }

 html = "<table><tr><td><table><tr>"; // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"b\");'>" + symBack + "</td>";

 html += "<td class='scaleName'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrScales[m_CurrentScale].ScaleName;
 html += " Scale";
 html += "</td>";

 html += "<td class='btnScale' onclick='PlayScaleSound(new PlayScale(" + m_CurrentMode + ", " + m_CurrentKey + ", " + midiBase + ", " + m_CurrentScale + "), \"f\");'>" + symFwd + "</td>";

 html += GenOtherScaleInfo(key, notes);

 html += "</tr></table></tr></td><tr><td>";

 html += GenPianoOtherScaleKeys(2, key, arrScaleNotes, notes);

 html += "</td></tr></table>";

 return html; 
}

function GenPianoPlayBoard()
{
 var k;
 var html;
 var w;
 var i, o, x, text;
 var wMidi, midi, midiNum;
 var pWW, pBW;

 pWW = pianoWhiteWidth * 0.5;
 pBW = pianoBlackWidth * 0.5;

 html = "<table><tr><td><div style='position:relative; width:" + pianoWhiteWidth * 7 + "vw; height:" + pianoWhiteHeight + "vw;'>";

 w = 0;               // div x position
 wMidi = 24;
 
 x = 0;
 
 for (o=0;o<7; o++)
  {
   midiNum = wMidi;
   w = x;
   for (k=0; k<7; k++)  // 7 white keys from C to B
    {
     midi = m_mapMidiNotes.get(midiNum);
     if (midi != undefined)
       m_mapPlayInst.set(midiNum, ["dyPW_" + midiNum]);  
     html += "<div class='pianoPWhite' style='left:" + w.toString() + "vw;' onclick='ComposePlayNoteSound(new PlayNote(" + midiNum.toString() +", null));'>";
     html += "<div id='dyPW_" + midiNum + "' class='pianoPWhiteText' style='color:black; background-Color:white;'>" + NoteText(midi.Offset) + "</div>";
     html += "</div>";
     
     if (k==2 || k==6)  // E or B  key ??
      {
       midiNum += 1; // next white key
      }
     else
      { 
       midiNum += 2; // rest of the white keys are up 2
      }
     w += pWW;
    }
   w =  x + pWW - (pBW / 2);  // center black keys in middle of 1st white key
   midiNum = wMidi + 1;  // starting midi note of black keys
   for (k=0; k<5; k++) // 5 black keys
    {
     midi = m_mapMidiNotes.get(midiNum);
     midi = m_mapMidiNotes.get(midiNum);
     if (midi != undefined)
       m_mapPlayInst.set(midiNum, ["dyPB_" + midiNum]);  
     text = NoteText(midi.Offset);
     i = text.indexOf("/");
     if (i>0)
       text = text.substring(0,i) + "<br>" + text.substring(i+1);
     html += "<div class='pianoPBlack' style='left:" + w.toString() + "vw;' onclick='PlayNoteSound(new PlayNote(" + midiNum.toString() +", null));'>";
     html += "<div id='dyPB_" + midiNum + "' class='pianoPBlackText' style='color:black; background-Color:white;'>" + text + "</div>";
     html += "</div>"; 
     if (k==1 || k==4) // is the next key an f# or c#
      {
       w += pWW * 2;  // move next f# or c# over 2 white key widths
       midiNum += 3;                 // note offset is bumped 3
      }
     else
      {
       w += pWW;   // these keys are next to each other  
       midiNum += 2;               
      }
    }
   wMidi += 12;
   x += pWW * 7;
  }
 html += "</div></td></tr></table>";

 document.getElementById("divPlayInst").innerHTML = html;

}

//////////////////////////////////////////////
//            Load Combo Boxes
//////////////////////////////////////////////

function dynaModesLoaderTH()
{
 var i,oOption;
 
 document.getElementById("cboModesTH").options.length=0;
 
 for (i=0;i<m_arrModes.length;i++)
  {
   if (m_arrModes[i].KeyList.length > 0 && m_arrModes[i].ChordType.length > 0)  // only add modes that I've filled out the key list
    {
     oOption=document.createElement("OPTION");
     oOption.style.backgroundColor=m_arrModes[i].Background;
     oOption.text=m_arrModes[i].ModeName;
     oOption.value=m_arrModes[i].ID;
     document.getElementById("cboModesTH").options.add(oOption);
    }
  } 
 eventCboModesTH_Change();
}

function dynaModesLoaderChord()
{
 var i,oOption;
 
 document.getElementById("cboModesChord").options.length=0;
 
 for (i=0;i<m_arrModes.length;i++)
  {
   if (m_arrModes[i].KeyList.length > 0 && m_arrModes[i].ChordType.length > 0)  // only add modes that I've filled out the key list
    {
     oOption=document.createElement("OPTION");
     oOption.style.backgroundColor=m_arrModes[i].Background;
     oOption.text=m_arrModes[i].ModeName;
     oOption.value=m_arrModes[i].ID;
     document.getElementById("cboModesChord").options.add(oOption);
    }
  } 
 eventCboModesChord_Change();
}

function dynaModesLoaderScale()
{
 var i,oOption;
 
 document.getElementById("cboModesScale").options.length=0;
 
 for (i=0;i<m_arrModes.length;i++)
  {
   if (m_arrModes[i].KeyList.length > 0)  // only add modes that I've filled out the key list
    {
     oOption=document.createElement("OPTION");
     oOption.style.backgroundColor=m_arrModes[i].Background;
     oOption.text=m_arrModes[i].ModeName;
     oOption.value=m_arrModes[i].ID;
     document.getElementById("cboModesScale").options.add(oOption);
    }
  } 
 eventcboModesScale_Change();
}

function dynaOtherScaleLoader()
{
 var i,oOption;
 
 document.getElementById("cboOtherScales").options.length=0;
 
 for (i=0;i<m_arrScales.length;i++)
  {
   oOption=document.createElement("OPTION");
   oOption.style.backgroundColor=m_arrScales[i].Background;
   oOption.text=m_arrScales[i].ScaleName;
   oOption.value=i.toString();
   document.getElementById("cboOtherScales").options.add(oOption);
  } 
 eventcboOtherScales_Change();
}

function dynaCapoLoader()
{
 var i, s, oOption;

 for(i=0;i<m_arrInstruments[m_Guitar].Frets; i++)
  {
   oOption=document.createElement("OPTION");
   if (i==0)
     s="None";
   else
     s="Fret " + i.toString();
   oOption.text=s;
   oOption.value=i;   
   document.getElementById("cboGuitarCapo").options.add(oOption);
  }
 for(i=0;i<m_arrInstruments[m_Bass].Frets; i++)
  {
   oOption=document.createElement("OPTION");
   if (i==0)
     s="None";
   else
     s="Fret " + i.toString();
   oOption.text=s;
   oOption.value=i;   
   document.getElementById("cboBassCapo").options.add(oOption);
  }
 for(i=0;i<m_arrInstruments[m_Mandolin].Frets; i++)
  {
   oOption=document.createElement("OPTION");
   if (i==0)
     s="None";
   else
     s="Fret " + i.toString();
   oOption.text=s;
   oOption.value=i;   
   document.getElementById("cboMandolinCapo").options.add(oOption);
  }
 for(i=0;i<m_arrInstruments[m_Ukulele].Frets; i++)
  {
   oOption=document.createElement("OPTION");
   if (i==0)
     s="None";
   else
     s="Fret " + i.toString();
   oOption.text=s;
   oOption.value=i;   
   document.getElementById("cboUkuleleCapo").options.add(oOption);
  }
}

function dynaTuneLoader()
{
 var i, oOption;

 for (i=0; i<m_arrInstruments[m_Guitar].Tunings.length; i++)
  {
   oOption=document.createElement("OPTION");
   oOption.text= m_arrInstruments[m_Guitar].Tunings[i].TuningName;
   oOption.value=i;   
   document.getElementById("cboGuitarTune").options.add(oOption);
  }

 for (i=0; i<m_arrInstruments[m_Bass].Tunings.length; i++)
  {
   oOption=document.createElement("OPTION");
   oOption.text= m_arrInstruments[m_Bass].Tunings[i].TuningName;
   oOption.value=i;   
   document.getElementById("cboBassTune").options.add(oOption);
  }

 for (i=0; i<m_arrInstruments[m_Mandolin].Tunings.length; i++)
  {
   oOption=document.createElement("OPTION");
   oOption.text= m_arrInstruments[m_Mandolin].Tunings[i].TuningName;
   oOption.value=i;   
   document.getElementById("cboMandolinTune").options.add(oOption);
  }

 for (i=0; i<m_arrInstruments[m_Ukulele].Tunings.length; i++)
  {
   oOption=document.createElement("OPTION");
   oOption.text= m_arrInstruments[m_Ukulele].Tunings[i].TuningName;
   oOption.value=i;   
   document.getElementById("cboUkuleleTune").options.add(oOption);
  }
}

function dynaChordsAllRootsButtons()
{
 var html, i;

 html = "<table class='tableChordsRoot'><tr>"; 
 
 html += "<td class='tdVersion'>All Notes</td>";

 for (i=0;i<12;i++)
  {
   html += "<td class='tdChordsRoot' onclick='eventTDChordAllRootNote_Click(" + i + ");'>";
   html += NoteText(i);
   html += "</td>";
  }

 html += "</tr></table>";
 
 document.getElementById("tdChordAllNoteRoots").innerHTML = html;

}

////////////////////////////////////////////////
//               E v e n t s 
////////////////////////////////////////////////

function eventRadInstrument(inst) // Instrument radio button click
{
 m_CurrentInstrument = inst;
 switch(m_CurrentInstrument)
  {
   case m_Guitar:   GenGuitarPlayBoard();   break;
   case m_Bass:     GenBassPlayBoard();     break;
   case m_Mandolin: GenMandolinPlayBoard(); break;
   case m_Ukulele:  GenUkulelePlayBoard();  break;
   case m_Keyboard: GenPianoPlayBoard();    break;
  }
}

function eventCboKeysTH_Change() // Traditional Harmony Keys dropdown selection change 
{
 m_CurrentKey = parseInt(document.getElementById("cboKeysTH").options[document.getElementById("cboKeysTH").selectedIndex].value);

 m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);

 THShowChords();
 THShowScale();
 THShowModeChords();
}

function eventCboModesTH_Change() // Traditional Harmony Modes dropdown selection change
{
 var loadKeys, oOption;
 var i;
 var nm;

 nm = parseInt(document.getElementById("cboModesTH").options[document.getElementById("cboModesTH").selectedIndex].value);

 loadKeys = true;
 if (m_CurrentMode >= 0 && document.getElementById("cboKeysTH").optionslength > 0)
  {
   if (m_arrModes[m_CurrentMode].KeyList[0].Offset == m_arrModes[nm].KeyList[0].Offset) // do the modes share the same key list?
    {
     loadKeys = false; // no need to reload the Key combo box
    }
  }

 m_CurrentMode = nm;
  
 if (loadKeys == true)
  {
   document.getElementById("cboKeysTH").options.length = 0;

   for (i=0;i<m_arrModes[m_CurrentMode].KeyList.length;i++)
    {
     oOption=document.createElement("OPTION");
     oOption.style.backgroundColor=m_arrModes[m_CurrentMode].Background;
     oOption.text="Key of " + m_arrModes[m_CurrentMode].KeyList[i].Text;
     oOption.value=i;
     document.getElementById("cboKeysTH").options.add(oOption);
    }
   m_CurrentKey = 0;
  }

 m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);
 THShowChords();
 THShowScale();
 THShowModeChords();
}

function eventCboModesChord_Change()   // Chords section Modes dropdown selection change
{
 var loadKeys, oOption;
 var i;
 var nm;

 nm = parseInt(document.getElementById("cboModesChord").options[document.getElementById("cboModesChord").selectedIndex].value);

 loadKeys = true;
 if (m_CurrentMode >= 0 && document.getElementById("cboKeysChord").optionslength > 0)
  {
   if (m_arrModes[m_CurrentMode].KeyList[0].Offset == m_arrModes[nm].KeyList[0].Offset) // do the modes share the same key list?
    {
     loadKeys = false; // no need to reload the Key combo box
    }
  }

 m_CurrentMode = nm;

 if (loadKeys == true)
  { 
   document.getElementById("cboKeysChord").options.length = 0;

   for (i=0;i<m_arrModes[m_CurrentMode].KeyList.length;i++)
    {
     oOption=document.createElement("OPTION");
     oOption.style.backgroundColor=m_arrModes[m_CurrentMode].Background;
     oOption.text="Key of " + m_arrModes[m_CurrentMode].KeyList[i].Text;
     oOption.value=i;
     document.getElementById("cboKeysChord").options.add(oOption);
    }
  } 
 eventCboKeysChord_Change();  // fire the keys dropdown change to with the default selection
}

function eventcboModesScale_Change() // Scales section Modes dropdown selection change
{
 var loadKeys, oOption;
 var i;
 var nm;

 nm = parseInt(document.getElementById("cboModesScale").options[document.getElementById("cboModesScale").selectedIndex].value);

 loadKeys = true;
 if (m_CurrentMode >= 0 && document.getElementById("cboKeysScale").options.length > 0)
  {
   if (m_arrModes[m_CurrentMode].KeyList[0].Offset == m_arrModes[nm].KeyList[0].Offset) // do the modes share the same key list?
    {
     loadKeys = false; // no need to reload the Key combo box
    }
  }

 m_CurrentMode = nm;

 if (loadKeys == true)
  {
   document.getElementById("cboKeysScale").options.length = 0;
   for (i=0;i<m_arrModes[m_CurrentMode].KeyList.length;i++)
    {
     oOption=document.createElement("OPTION");
     oOption.style.backgroundColor=m_arrModes[m_CurrentMode].Background;
     oOption.text="Key of " + m_arrModes[m_CurrentMode].KeyList[i].Text;
     oOption.value=i;
     document.getElementById("cboKeysScale").options.add(oOption);
    }
  }

 eventcboKeysScale_Change();
}


function eventCboKeysChord_Change() // Chord section Keys dropdown selection change
{
 var html, i;

 if (document.getElementById("cboKeysChord").options.length == 0)
   return;

 m_CurrentKey = parseInt(document.getElementById("cboKeysChord").options[document.getElementById("cboKeysChord").selectedIndex].value);

 m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);

 html = "<table class='tableChordsRoot'><tr>"; 

 for (i=0;i<m_Key.Notes.length;i++)
  {
   html += "<td class='tdChordsRoot' onclick='eventTDChordRootNote_Click(" + i + ");'>";
   html += m_Key.Notes[i].Text;
   html += "</td>";
  }

 html += "</tr></table>";
 
 document.getElementById("tdChordRoots").innerHTML = html;
 
}

function eventcboKeysScale_Change()  // Scale section Key dropdown selection change
{
 m_CurrentKey = parseInt(document.getElementById("cboKeysScale").options[document.getElementById("cboKeysScale").selectedIndex].value);

 m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);
}

function eventcboPatternsChord_Change() // Chord section Pattern dropdown selection change
{
 m_CurrentChordPattern =  parseInt(document.getElementById("cboPatternsChord").options[document.getElementById("cboPatternsChord").selectedIndex].value);
}

function eventTDChordRootNote_Click(keyNdx) // Chord section root note TD "buttons" click
{
 var html, i, k, r;
 var outofkey, off;
 var midi;

 m_CurrentChordRoot = m_Key.Notes[keyNdx];  // m_CurrentChordRoot is a Note object

 html = "<table class='tableDlgPattern'>";
 html += "<tr>";
 r = 0;
 for (i=0; i<m_arrChordPatterns.length; i++)
  {
   outofkey = false;  // see if this chord pattern results in notes that would be out of key
   for (k=0; k<m_arrChordPatterns[i].Pitches.length; k++)
    {
     off = m_CurrentChordRoot.Offset + m_arrChordPatterns[i].Pitches[k];
     if (off >= 12)
       off -= 12;
     if (m_Key.OffsetNote(off) == null) // see if the note is out of key
       outofkey = true;
    }      
   if (r==4)
    {
     if (i>0)
       html += "</tr>";
     html += "<tr>";
     r = 0;
    }
   html += "<td class='tdDlgPattern' ";
   if (outofkey == true)
     html += "title='This chord would be out of key' ";
   html += "onclick='eventDialogChordPattern_Click(" + i + ");'>";
   midi = m_Key.BaseMidi + m_CurrentChordRoot.Offset;
   html += "<span class='spanPatInKey' onclick='PlayChordSound(new PlayChord(" + m_CurrentMode + ", " + m_CurrentKey + ", " + i + ", " + midi + ")); event.stopPropagation();' ";
   if (outofkey == true)
     html += "style='color:red;'>" + symNot + "</span> &nbsp; ";
   else
     html += "style='color:green;'>" + symNote + "</span> &nbsp; ";
   html += m_arrChordPatterns[i].Name;
   html += "</td>";
   r++;
  }

 if (r==4)
  html += "<tr>";
 html += "<td class='tdDlgPattern' onclick='eventDialogChordPattern_Click(-1);'>";
 html += "Cancel";
 html += "</td>";
 html += "</tr>";
 html += "</table>";

 document.getElementById("divDialog").innerHTML = html;
 document.getElementById("divDialogBase").style.display = "block";
}

function eventTDChordAllRootNote_Click(offset) // Chord section root note TD "buttons" click
{
 var html, i, r;
 var midi;

 html = "<table class='tableDlgPattern'>";
 html += "<tr>";
 r = 0;
 for (i=0; i<m_arrChordPatterns.length; i++)
  {
   if (r==4)
    {
     if (i>0)
       html += "</tr>";
     html += "<tr>";
     r = 0;
    }
   html += "<td class='tdDlgPattern' ";
   html += "onclick='eventDialogChordPatternAllRoots_Click(" + i + "," + offset + ");'>";
   midi = m_Key.BaseMidi + offset;
   html += "<span class='spanPatInKey' onclick='PlayChordSound(new PlayChord(" + m_CurrentMode + ", " + m_CurrentKey + ", " + i.toString() + ", " + midi.toString() + ")); event.stopPropagation();' ";
   html += "style='color:green;'>" + symNote + "</span> &nbsp; ";
   html += m_arrChordPatterns[i].Name;
   html += "</td>";
   r++;
  }

 if (r==4)
  html += "<tr>";
 html += "<td class='tdDlgPattern' onclick='eventDialogChordPatternAllRoots_Click(-1);'>";
 html += "Cancel";
 html += "</td>";
 html += "</tr>";
 html += "</table>";

 document.getElementById("divDialog").innerHTML = html;
 document.getElementById("divDialogBase").style.display = "block";
}


function eventDialogChordPattern_Click(patternNdx) // Dialog box TD Chord pattern "button" click generated above
{
 var html, table, row, td, cn, midiRoot;
 
 document.getElementById("divDialogBase").style.display = "none";
 document.getElementById("divDialog").innerHTML = "";

 if (patternNdx < 0) // cancel?
   return;

 table = document.getElementById("tableChords");

 row = table.insertRow(table.rows.length);
 
 td = row.insertCell(0);

 cn = m_CurrentChordRoot.Offset;
 midiRoot = m_Key.BaseMidi + cn; // C3 + the offset

 html = "<table><tr><td class='tdSideChord'>";
 html += GenChordInfo(patternNdx, cn, m_Key, midiRoot);
 html += "</td><td>";

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   html += GenGuitar(patternNdx, cn, m_Key);   break;
   case m_Bass:     html += GenBass(patternNdx, cn, m_Key);     break;
   case m_Mandolin: html += GenMandolin(patternNdx, cn, m_Key); break;
   case m_Ukulele:  html += GenUkulele(patternNdx, cn, m_Key);  break;
   case m_Keyboard: html += GenPianoChord(3, patternNdx, cn, m_Key); break; 
  }

 html += "</td></tr></table>";

 td.innerHTML = html;
}


function eventDialogChordPatternAllRoots_Click(patternNdx, cn) // Dialog box TD Chord pattern "button" click generated above, cn is note offset C = 0
{
 var html, table, row, td, midiRoot;
 
 document.getElementById("divDialogBase").style.display = "none";
 document.getElementById("divDialog").innerHTML = "";

 if (patternNdx < 0) // cancel?
   return;

 table = document.getElementById("tableChords");

 row = table.insertRow(table.rows.length);
 
 td = row.insertCell(0);

 midiRoot = m_Key.BaseMidi + cn; // C3 + the offset

 html = "<table><tr><td class='tdSideChord'>";
 html += GenChordInfo(patternNdx, cn, m_Key, midiRoot);
 html += "</td><td>";

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   html += GenGuitar(patternNdx, cn, m_Key);   break;
   case m_Bass:     html += GenBass(patternNdx, cn, m_Key);     break;
   case m_Mandolin: html += GenMandolin(patternNdx, cn, m_Key); break;
   case m_Ukulele:  html += GenUkulele(patternNdx, cn, m_Key);  break;
   case m_Keyboard: html += GenPianoChord(3, patternNdx, cn, m_Key); break; 
  }

 html += "</td></tr></table>";

 td.innerHTML = html;
}


function eventBtnChordClear_Click() // Chords section Clear button click
{
 var table = document.getElementById("tableChords");

 table.innerHTML = "";
}

function eventBtnScaleAdd_Click() // Scales section Add button click
{
 var html, table, row, td;

 table = document.getElementById("tableScales");

 row = table.insertRow(table.rows.length);
 
 td = row.insertCell(0);

 html = "<table><tr><td class='tdScaleInst'>";

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   html += GenGuitarScale(m_Key);   break;
   case m_Bass:     html += GenBassScale(m_Key);     break;
   case m_Mandolin: html += GenMandolinScale(m_Key); break;
   case m_Ukulele:  html += GenUkuleleScale(m_Key);  break;
   case m_Keyboard: html += GenPianoScale(m_Key, m_CurrentMode); break; 
  }

 html += "</td></tr></table>";

 td.innerHTML = html;

}

function eventcboOtherScales_Change()
{
 m_CurrentScale = parseInt(document.getElementById("cboOtherScales").options[document.getElementById("cboOtherScales").selectedIndex].value);
}

function eventBtnScaleClear_Click() // Scales section Clear button click
{
 var table = document.getElementById("tableScales");

 table.innerHTML = "";
}

function eventBtnOtherScaleAdd_Click()
{
 var html, table, row, td;
 var notes = [];
 var offset;
 var note;
 var i, k, ndx;

 offset = m_Key.Offset;

 for(i=0; i<m_arrScales[m_CurrentScale].Sequences.length; i++)
  {
   note = null;
   for(k=0; k<m_Key.Notes.length; k++)
     {
      if (m_Key.Notes[k].Offset == offset)
        note = m_Key.Notes[k];
     }
   if (note != null)
     notes[i] = note;
   else
    {
     if (m_arrScales[m_CurrentScale].LookUps[i] != null)
      {
       ndx = m_arrScales[m_CurrentScale].LookUps[i][0];
       note = m_Key.Notes[ndx];
       notes[i] = note.NextNote(m_arrScales[m_CurrentScale].LookUps[i][1]);
      }
     else
      {
       note = new Note(offset, NoteText(offset), null);
       notes[i] = note;
      }
    }
   offset += m_arrScales[m_CurrentScale].Sequences[i];
   if (offset >= 12)
     offset -= 12;
  }

 table = document.getElementById("tableScales");
 row = table.insertRow(table.rows.length);
 td = row.insertCell(0);

 html = "<table><tr><td class='tdScaleInst'>";

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   html += GenGuitarOtherScale(m_Key, notes);   break;
   case m_Bass:     html += GenBassOtherScale(m_Key, notes);     break;
   case m_Mandolin: html += GenMandolinOtherScale(m_Key, notes); break;
   case m_Ukulele:  html += GenUkuleleOtherScale(m_Key, notes);  break;
   case m_Keyboard: html += GenPianoOtherScale(m_Key, notes);    break; 
  }

 html += "</td></tr></table>";

 td.innerHTML = html;
}

function eventcboGuitarCapo_Change() // Settings section guitar capo dropdown selection change
{
 m_CurrentGuitarCapo =  parseInt(document.getElementById("cboGuitarCapo").options[document.getElementById("cboGuitarCapo").selectedIndex].value);
}

function eventcboBassCapo_Change()  // Settings section bass guitar capo dropdown selection change
{
 m_CurrentBassCapo =  parseInt(document.getElementById("cboBassCapo").options[document.getElementById("cboBassCapo").selectedIndex].value);
}

function eventcboMandolinCapo_Change() // Settings section mandolin capo dropdown selection change
{
 m_CurrentMandolinCapo =  parseInt(document.getElementById("cboMandolinCapo").options[document.getElementById("cboMandolinCapo").selectedIndex].value);
}

function eventcboUkuleleCapo_Change() // Settings section ukulele capo dropdown selection change
{
 m_CurrentUkuleleCapo =  parseInt(document.getElementById("cboUkuleleCapo").options[document.getElementById("cboUkuleleCapo").selectedIndex].value);
}

function eventcboGuitarTune_Change() // Settings section guitar alternate tuning dropdown selection change
{
 m_CurrentGuitarTuning =  parseInt(document.getElementById("cboGuitarTune").options[document.getElementById("cboGuitarTune").selectedIndex].value);
 makeGuitar();
}

function eventcboBassTune_Change() // Settings section bass guitar alternate tuning dropdown selection change
{
 m_CurrentBassTuning =  parseInt(document.getElementById("cboBassTune").options[document.getElementById("cboBassTune").selectedIndex].value);
 makeBass();
}

function eventcboMandolinTune_Change() // Settings section mandolin alternate tuning dropdown selection change
{
 m_CurrentMandolinTuning =  parseInt(document.getElementById("cboMandolinTune").options[document.getElementById("cboMandolinTune").selectedIndex].value);
 makeMandolin();
}

function eventcboUkuleleTune_Change()  // Settings section ukulele alternate tuning dropdown selection change
{
 m_CurrentUkuleleTuning =  parseInt(document.getElementById("cboUkuleleTune").options[document.getElementById("cboUkuleleTune").selectedIndex].value);
 makeUkulele();
}

function eventRadFingering(opt) // Settings section Fingering display radio button click,  either numbers 1 2 3 4 or letters I M R P
{
 m_CurrentFingeringOption = opt;
 if (opt == optFingeringNumbers)
   m_arrFingering = ["1", "2", "3", "4"];
 else
   m_arrFingering = ["I", "M", "R", "P"];
}

function eventcboAudioWave_Change() // Settings section audio waveform dropdown selection change
{
 m_CurrentWave = document.getElementById("cboAudioWave").options[document.getElementById("cboAudioWave").selectedIndex].value;
}

function eventChkRecord_Click()
{
 m_RecordMode = document.getElementById("chkRecord").checked;
}

function eventBtnRecordClear_Click()
{
 m_arrRecordBuffer = [];
 ShowRecordBuffer();
}

function eventCboTimeSignature_Change()
{
 m_CurrentTimeSignature = parseInt(document.getElementById("cboStaveTime").options[document.getElementById("cboStaveTime").selectedIndex].value);
 ShowPlayBuffer();
}

function eventTDPlaySixteenth_Click(buffer, sixteenth)
{
 var i;

 m_CurrentPlayBuffer = buffer; // set which of the play buffers is selected
 for (i=0; i<5; i++)
  {
   document.getElementById("radPlayBuffer" + i).checked = false;  // uncheck all of the buffer radio buttons
  }
 document.getElementById("radPlayBuffer" + buffer).checked = true; // check the new one
 m_CurrentPlaySixteenth = sixteenth;                               // set the current 1/16 time slice 
 m_arrPlayBuffers[buffer][sixteenth] = null;                       // clear the entry at the click point so indivdual notes and chords can be cleared 
 ShowPlayBuffer();
}

function eventBtnClearSelectedBuffer()
{
 var i;

 for(i=0; i<m_arrPlayBuffers[m_CurrentPlayBuffer].length; i++)
   m_arrPlayBuffers[m_CurrentPlayBuffer][i] = null;
 ShowPlayBuffer();
}

function eventBtnPlayBuffers()
{
 SoundPlayCheckedBuffers();
}

function eventRadPlayBufferSelect(buffer)
{
 m_CurrentPlayBuffer = buffer;
 ShowPlayBuffer();
}

function eventBtnSubmit()
{
 SubmitForm();
}

function eventSliderBPM()
{
 var bpm = parseInt(document.getElementById("beatsPerMinute").value);
 
 document.getElementById("spanBPM").innerHTML = bpm + " bpm";  // need to calculate milliseconds between a measure

 m_CurrentPlayTime = Math.round(1000 * 60/bpm) * 4;    //  60 / 60 = 1,  60/120 = 0.5

}

function eventSliderVol()
{
 var vol = document.getElementById("audioVolumeRecord").value;
 
 document.getElementById("spanVol").innerHTML = vol + " Vol";  // need to calculate milliseconds between a measure
}


function eventSliderLength()
{
 var len = document.getElementById("audioLengthRecord").value;
 
 document.getElementById("spanLength").innerHTML = len + " Dur";  // need to calculate milliseconds between a measure

 m_CurrentPlayPercLenth = parseFloat(len);
}

function eventSliderMaster()
{
 var vol;

 vol = document.getElementById("audioVolumeControl").value;

 document.getElementById("spanMasterVol").innerHTML = vol;

 m_MasterVol = vol;

}


////////////////////////////////////////////////
//               S h o w   
////////////////////////////////////////////////

// high level show mode chords, instrument chords & instrument scales

function THShowChords()
{
 var pattern;
 var i;
 var cn, s;
 var midi;

 if (m_CurrentKey == -1 || m_CurrentMode == -1)
  {
   for (i=0; i<7; i++)
    {
     document.getElementById("tdChord" + i.toString()).innerHTML="";
    }
   return;
  }

 cn = m_Key.Offset;
 midi = m_Key.BaseMidi; // C3 + the offset, midi root of the current chord

 for (i=0; i<7; i++)
  {
   pattern = m_arrModes[m_CurrentMode].ChordType[i];
   document.getElementById('tdChord' + i.toString()).innerHTML = GenChordInfo(pattern, cn, m_Key, midi);
   switch(m_CurrentInstrument)
    {
     case m_Guitar:   s = GenGuitar(pattern, cn, m_Key);   break;
     case m_Bass:     s = GenBass(pattern, cn, m_Key);     break;
     case m_Mandolin: s = GenMandolin(pattern, cn, m_Key); break;
     case m_Ukulele:  s = GenUkulele(pattern, cn, m_Key);  break;
     case m_Keyboard: s = GenPianoChord(3, pattern, cn, m_Key); break; 
    }
   document.getElementById('tdChordInst' + i.toString()).innerHTML = s;
   midi += m_arrModes[m_CurrentMode].Sequences[i];
   cn += m_arrModes[m_CurrentMode].Sequences[i];
   if (cn >= 12)
     cn -= 12;
  }
 document.getElementById("tdHarmonyInstrument").innerHTML = m_arrInstruments[m_CurrentInstrument].InstrumentName;
}

function THShowScale() // Show the Traditional Harmony scale instrument
{
 var s;

 if (m_CurrentKey == -1 || m_CurrentMode == -1)
  {
   document.getElementById("tdScaleInst").innerHTML="";
   return;
  }

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   s = GenGuitarScale(m_Key);                break;
   case m_Bass:     s = GenBassScale(m_Key);                  break;
   case m_Mandolin: s = GenMandolinScale(m_Key);              break;
   case m_Ukulele:  s = GenUkuleleScale(m_Key);                    break;
   case m_Keyboard: s = GenPianoScale(m_Key, m_CurrentMode);  break;
  }
 document.getElementById('tdScaleInst').innerHTML = s;
}

function THShowModeChords() // Traditional Harmony section show the table of chords based on the selected mode and key selections
{
 var s;

 s = genModeChords();

 document.getElementById('tdModeChordsTH').innerHTML = s;
}

function THHideChords() // Clear the traditional harmony chord TDs
{
 var i;

 document.getElementById("tdScaleInst").innerHTML="";
 for (i=0; i<7; i++)
  {
   document.getElementById("tdChord" + i.toString()).innerHTML="";
  }
 return;
}

function ShowRecordBuffer()
{
 var html;
 var rt;
 var i, k;

 html = "";

 for (i=0; i<m_arrRecordBuffer.length; i++)
  {
   rt = m_arrRecordBuffer[i]; // get RecordThing object
   switch(rt.RecordType)
    {
     case "N":
      {
       html += "<div class='tdRecordBufferN'><table>";
       html += "<tr><td class='tdRecordBuffTop' onclick='ComposePlayNoteSound(new PlayNote(" + rt.Note.Midi.Number + ", " + Quotes(rt.Note.Text) + "));'>&nbsp;</td></tr>";
       html += "<tr><td>" +  rt.Note.Text + rt.Note.Midi.Octave + "</td></tr>";
       html += "<tr><td class='tdRecordBuffBot' onclick='AddNoteToStave(" + i + ");'>&nbsp;</td></tr></table></div>";
      } break;
     case "C":
      {
       html += "<div class='tdRecordBufferC'><table>";
       html += "<tr><td class='tdRecordBuffTop' onclick='ComposePlayChordSound(new PlayChord(" + rt.Chord.Mode + ", " + rt.Chord.KeyIndex + ", " + rt.Chord.Pattern + ", " + rt.Chord.Notes[0].Midi.Number + "));'>&nbsp;</td></tr>";
       html += "<tr>";
       html += "<td><table><tr>";
       html += "<td class='tdRecBuffOctave' onclick='ChordOctaveBack(" + i + ");'>" + symBack + "</td>";
       html += "<td>" + rt.Chord.Text + "</td>";                  // so no 2 note power chords
       html += "<td class='tdRecBuffOctave' onclick='ChordOctaveFwd(" + i + ");'>" + symFwd + "</td>";
       html += "</tr></table>";
       html += "<tr><td style='text-align:center;'><table>";
       for (k=0; k<rt.Chord.Notes.length; k++)
         html += "<td class='tdRecChordNote' onclick='AddChordNoteToStave(" + i + ", " + k + ");'>" + rt.Chord.Notes[k].Text + rt.Chord.Notes[k].Midi.Octave + "</td>";
       html += "</tr></table></td>";
       html += "</tr></td>";
       html += "<tr><td class='tdRecordBuffBot' onclick='AddChordToStave(" + i + ");'>&nbsp;</td></tr></table></div>";
      } break;
     case "S":
      {
       html += "<div class='tdRecordBufferS'><table>";
       html += "<tr><td class='tdRecBuffScale'>" + rt.Scale.Text + "</td></tr>";
       html += "<tr><td><table><tr>";
       html += "<td class='tdRecBuffOctave' onclick='ScaleOctaveBack(" + i + ");'>" + symBack + "</td>";
       for (k=0; k<rt.Scale.Notes.length; k++)
        {
         html += "<td><table><tr><td class='tdRecordBuffTop' onclick='ComposePlayNoteSound(new PlayNote(" + rt.Scale.Notes[k].Midi.Number + ", " + Quotes(rt.Scale.Notes[k].Text) + "));'>&nbsp;</td></tr>";
         html += "<tr><td>" +  rt.Scale.Notes[k].Text + rt.Scale.Notes[k].Midi.Octave + "</td></tr>";
         html += "<tr><td class='tdRecordBuffBot' onclick='AddScaleNoteToStave(" + i + ", " + k + ");'>&nbsp;</td></tr></table></td>";
        }
       html += "<td class='tdRecBuffOctave' onclick='ScaleOctaveFwd(" + i + ");'>" + symFwd + "</td>";
       html += "</tr></table></tr></table></div>";
      } break;
    }
  }

 document.getElementById("divRecordBuffer").innerHTML = html;
}

function ShowPlayBufferCell(playThing)
{
 var html;
 var time;
 var text = symBlock;
 var vol, oct;

 html = "<div class='divSixteenth'>";

 if (playThing != null)
  {
   switch(playThing.PlayType)
    {
     case "N": text = playThing.Note.Text; oct = playThing.Note.Midi.Octave;  break;
     case "C": text = playThing.Chord.Text; oct = playThing.Chord.Notes[0].Midi.Octave; break;
    }
   vol = playThing.Volume;
   switch(playThing.DisplayTime)
    {
     case 1: time="whole"; break;
     case 2: time="half";  break;
     case 4: time="1/4";   break;
     case 8: time="1/8"; break;
     case 16: time="1/16"; break;
    }
   html += "<div class='tdPlayBuffMain'>" + text + "</div>";
   html += "<div class='tdPlayBuffVol'>" + oct + "&nbsp;" + vol + "</div>";
   html += "<div class='tdPlayBuffTime'>" + time + "</div>";
  }
 else
  {
   html += "<div class='tdPlayBuffMain' style='color:white; background-color:white;'>" + text + "</div>";
   html += "<div class='tdPlayBuffVol' style='color:white; background-color:white;'>&nbsp;</div>";
   html += "<div class='tdPlayBuffTime' style='color:white; background-color:white;'>&nbsp;</div>";
  }
 
 html += "</div>";
 
return html;
}

function ShowPlayBuffer()
{
 var html;
 var i, k, j;
 var measures, n16Ndx;
 var n16, n16Count;
 var fg, bg; 
 var quarter;
 
 switch(m_CurrentTimeSignature)
  {
   case 1: // 4/4 time
    {
     n16 = 16;  // 16 16th notes in a measure
    } break;
   case 2: // 3/4 time
    {
     n16 = 12;
    } break;
   case 3: // 2/4 time
    {
     n16 = 8;
    } break;
   case 4: // 6/8 time
    {
     n16 = 24; // xxxx xxxx xxxx xxxx xxxx xxxx |
    } break;
  }
 
 n16Count = 0;

 for (i=0;i<m_arrPlayBuffers.length; i++)
  {
   measures = m_arrPlayBuffers[i].length / n16;
   n16Ndx = 0;
   html = "<table><tr>";
   for (k=0; k<measures; k++)
    {
     html += "<td class='tdMeasure'><table><tr>";
     quarter = 0;
     for (j=0; j<n16; j++) // go through the 16th notes
      {
       if (quarter == 4)
        {
         html += "<td class='tdQuarter'></td>";
         quarter = 0;
        }
       quarter++;       
       if (m_arrPlayBuffers[i][n16Ndx] != null)
        {
         fg = "white";
         bg = "black";
        }
       else
        {
         fg = "#dddddd";
         bg = "#999999";
        }
       if (m_CurrentPlayBuffer == i && m_CurrentPlaySixteenth == n16Ndx)
        {
         bg = "lime";
        }
       html += "<td class='tdSixteenth' style='padding:0.2vw; color:" + fg + "; background-color:" + bg + ";' ";
       html += "onclick='eventTDPlaySixteenth_Click(" + i + ", " + n16Ndx + ");'>";
       html += ShowPlayBufferCell(m_arrPlayBuffers[i][n16Ndx]);
       html += "</td>";
       n16Ndx++;
      }
     html += "</tr></table></td>";
    }
   html += "</tr></table>";
   document.getElementById("tdPlayBuffer" + i).innerHTML = html;
  }

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   GenGuitarPlayBoard();   break;
   case m_Bass:     GenBassPlayBoard();     break;
   case m_Mandolin: GenMandolinPlayBoard(); break;
   case m_Ukulele:  GenUkulelePlayBoard();  break;
   case m_Keyboard: GenPianoPlayBoard();    break;
  }
}

// tab content button click handler

function openPage(pageNum, pageName, btn) 
{
 var i, tabs, btns;
 
 // Hide all tabContent divs
 tabs = document.getElementsByClassName("tabContent");
 for (i=0; i<tabs.length; i++) 
  {
   tabs[i].style.display = "none";
  }

  // Remove the background color of all tablinks/buttons
 btns = document.getElementsByClassName("tabLink");
 for (i=0; i<btns.length; i++) 
  {
   btns[i].style.color="";
   btns[i].style.backgroundColor = ""; // bg color diverts back to the css class
  }
 
  // Show the specific tab content
 document.getElementById(pageName).style.display = "block";

  // Add the specific color to the button used to open the tab content
 btn.style.backgroundColor = "white";
 btn.style.color = "black";

 switch(pageNum)
  {
   case 0:
    {
    } break;
   case 1:
    {
     m_CurrentMode = parseInt(document.getElementById("cboModesTH").options[document.getElementById("cboModesTH").selectedIndex].value);
     m_CurrentKey = parseInt(document.getElementById("cboKeysTH").options[document.getElementById("cboKeysTH").selectedIndex].value);
     m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);
    } break;
   case 2:
    {
     m_CurrentMode = parseInt(document.getElementById("cboModesChord").options[document.getElementById("cboModesChord").selectedIndex].value);
     m_CurrentKey = parseInt(document.getElementById("cboKeysChord").options[document.getElementById("cboKeysChord").selectedIndex].value);
     m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);
    } break;
   case 3:
    {
     m_CurrentMode = parseInt(document.getElementById("cboModesScale").options[document.getElementById("cboModesScale").selectedIndex].value);
     m_CurrentKey = parseInt(document.getElementById("cboKeysScale").options[document.getElementById("cboKeysScale").selectedIndex].value);
     m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);
    } break;
   case 4:
     {
      ShowRecordBuffer();
      ShowPlayBuffer();
     } break;
  }

}

// Serialization

function AppendText(form, vari, val)
{
 var ctrl;

 ctrl = document.createElement("input");
 ctrl.type = "text";
 ctrl.name = vari;
 ctrl.value = val;
 form.appendChild(ctrl);
}

function AppendRecordThing(form, recNdx)
{
 var rt;

 rt = m_arrRecordBuffer[recNdx]; // RecordThing objects

 AppendText(form, "rT" + recNdx, rt.RecordType);
 
 switch(rt.RecordType)
  {
   case "N":
    {
     AppendText(form, "rNM" + recNdx, rt.Note.Midi.Number);
     AppendText(form, "rNT" + recNdx, rt.Note.Text);
    } break;
   case "C":
    {
     AppendText(form, "rCM" + recNdx, rt.Chord.Mode);
     AppendText(form, "rCK" + recNdx, rt.Chord.KeyIndex);
     AppendText(form, "rCP" + recNdx, rt.Chord.Pattern);
     AppendText(form, "rCN" + recNdx, rt.Chord.Notes[0].Midi.Number);
    } break;
   case "S":
    {
     AppendText(form, "rSM" + recNdx, rt.Scale.Mode);
     AppendText(form, "rSK" + recNdx, rt.Scale.KeyIndex);
     AppendText(form, "rSN" + recNdx, rt.Scale.MidiBase);
     AppendText(form, "rSO" + recNdx, rt.Scale.OtherScale);
    } break;
  } 
}

function ReadRecordThing(params, ndx)
{
 var pt;
 var v1, v2, v3, v4;

 if (params.has("rT" + ndx) == false)  // plaything type?
   return;

 pt = params.get("rT" + ndx);

 switch(pt)
  {
   case "N":
    {
     if (params.has("rNM" + ndx) == false) // note's midi #
       return;                              // nope, bail
     v1 = parseInt(params.get("rNM" + ndx));
     if (params.has("rNT" + ndx) == false) // note's text
       return;                              // nope, bail
     v2 = params.get("rNT" + ndx);
     m_arrRecordBuffer.push(new RecordThing("N", new PlayNote(v1, v2), null, null));
    } break;
   case "C":
    {
     if (params.has("rCM" + ndx) == false) // chords's mode
       return;                              // nope, bail
     v1 = parseInt(params.get("rCM" + ndx));
     if (params.has("rCK" + ndx) == false) // chords's KeyIndex
       return;                              // nope, bail
     v2 = parseInt(params.get("rCK" + ndx));
     if (params.has("rCP" + ndx) == false) // chords's pattern
       return;                              // nope, bail
     v3 = parseInt(params.get("rCP" + ndx));
     if (params.has("rCN" + ndx) == false) // chords midi base
       return;
     v4 = parseInt(params.get("rCN" + ndx));
     m_arrRecordBuffer.push(new RecordThing("C", null, new PlayChord(v1, v2, v3, v4), null)); 
    } break;
   case "S":
    {
     if (params.has("rSM" + ndx) == false) // scale's mode
       return;                              // nope, bail
     v1 = parseInt(params.get("rSM" + ndx));
     if (params.has("rSK" + ndx) == false) // scales's KeyIndex
       return;                              // nope, bail
     v2 = parseInt(params.get("rSK" + ndx));
     if (params.has("rSN" + ndx) == false) // scales's base midi note
       return;                              // nope, bail
     v3 = parseInt(params.get("rSN" + ndx));
     if (params.has("rSO" + ndx) == false) // scale's "other" scale index
       return;                              // nope, bail
     v4 = parseInt(params.get("rSO" + ndx));
     m_arrRecordBuffer.push(new RecordThing("S", null, null, new PlayScale(v1, v2, v3, v4)));
    } break;
   default: return;
  }
}

function AppendPlayThing(form, ndx, sndx)
{
 var pt;
 var wt;

 pt = m_arrPlayBuffers[ndx][sndx];

 AppendText(form, "pT" + ndx + "_" + sndx, pt.PlayType); // N or C
 switch(pt.WaveType)
  {
   case "square":   wt = "s1"; break;
   case "sine":     wt = "s2"; break;
   case "sawtooth": wt = "s3"; break;
   case "triangle": wt = "t";  break;
   default: throw new Error("invalid wavetype");
  }
 AppendText(form, "pW" + ndx + "_" + sndx, wt);             // abbreviate this to save on URL arg length
 AppendText(form, "pV" + ndx + "_" + sndx, pt.Volume);     
 AppendText(form, "pM" + ndx + "_" + sndx, pt.DisplayTime);  // pm = Play Milliseconds
 switch(pt.PlayType)
  {
   case "N": 
    {
     AppendText(form, "pNM" + ndx + "_" + sndx, pt.Note.Midi.Number);
     AppendText(form, "pNT" + ndx + "_" + sndx, pt.Note.Text);
    } break;
   case "C":
    {
     AppendText(form, "pCM" + ndx + "_" + sndx, pt.Chord.Mode);
     AppendText(form, "pCK" + ndx + "_" + sndx, pt.Chord.KeyIndex);
     AppendText(form, "pCP" + ndx + "_" + sndx, pt.Chord.Pattern);
     AppendText(form, "pCN" + ndx + "_" + sndx, pt.Chord.Notes[0].Midi.Number);    
    } break;
  }
}

function ReadPlayThing(params, ndx, sndx)
{
 var pt, wt, wave;
 var note, chord, vol, time;
 var v1, v2, v3, v4;

 if (params.has("pT" + ndx + "_" + sndx) == false)  // plaything type?
   return;                                           // nope, bail

 pt = params.get("pT" + ndx + "_" + sndx);

 if (params.has("pW" + ndx + "_" + sndx) == false)
   return;

 wt = params.get("pW" + ndx + "_" + sndx);
 switch(wt)
  {
   case "s1": wave = "square";   break;
   case "s2": wave = "sine";     break;
   case "s3": wave = "sawtooth"; break;
   case "t":  wave = "triangle"; break;
  }
 if (params.has("pV" + ndx + "_" + sndx) == false)
   return;
 vol = parseFloat(params.get("pV" + ndx + "_" + sndx));

 if (params.has( "pM" + ndx + "_" + sndx) == false)
   return;

 time = parseInt(params.get("pM" + ndx + "_" + sndx));

 switch(pt)
  {
   case "N":
    {
     if (params.has("pNM" + ndx + "_" + sndx) == false) // note's midi #
       return;                              // nope, bail
     v1 = parseInt(params.get("pNM" + ndx + "_" + sndx));
     if (params.has("pNT" + ndx + "_" + sndx) == false) // note's text
       return;                              // nope, bail
     v2 = params.get("pNT" + ndx + "_" + sndx);
     note = new PlayNote(v1, v2);
     chord = null;
    } break;
   case "C":
    {
     if (params.has("pCM" + ndx + "_" + sndx) == false) // chords's mode
       return;                              // nope, bail
     v1 = parseInt(params.get("pCM" + ndx + "_" + sndx));
     if (params.has("pCK" + ndx + "_" + sndx) == false) // chords's KeyIndex
       return;                              // nope, bail
     v2 = parseInt(params.get("pCK" + ndx + "_" + sndx));
     if (params.has("pCP" + ndx + "_" + sndx) == false) // chords's pattern
       return;                              // nope, bail
     v3 = parseInt(params.get("pCP" + ndx + "_" + sndx));
     if (params.has("pCN" + ndx + "_" + sndx) == false) // chords midi base, N = Note
       return;
     v4 = parseInt(params.get("pCN" + ndx + "_" + sndx));
     chord = new PlayChord(v1, v2, v3, v4);
     note = null; 
    } break;
   default: return;
  }
 m_arrPlayBuffers[ndx][sndx] = new PlayThing(pt, note, chord, wave, vol, time);
}

function SubmitForm()
{
 var form;
 var cbos, vars, cbo;
 var i, k, v;

 form = document.createElement("form");
 form.method = "get";

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   v = "G"; break;
   case m_Bass:     v = "B"; break;
   case m_Mandolin: v = "M"; break;
   case m_Ukulele:  v = "U"; break;
   case m_Keyboard: v = "K"; break;
  }
 AppendText(form, "radIn", v);

 cbos = ["cboGuitarCapo", "cboGuitarTune", "cboBassCapo", "cboBassTune", "cboMandolinCapo", "cboMandolinTune", "cboUkuleleCapo", "cboUkuleleTune", "cboStaveTime"];
 vars = ["cGC", "cGT", "cBC", "cBT", "cMC", "cMT", "cUC", "cUT", "cST"];

 for(i=0; i<cbos.length; i++)
  {
   cbo = document.getElementById(cbos[i]);
   v = cbo.options[cbo.selectedIndex].value;
   AppendText(form, vars[i], v);
  }

 AppendText(form, "cT", m_CurrentTimeSignature);
 AppendText(form, "rB", document.getElementById("beatsPerMinute").value);
 AppendText(form, "rD", m_CurrentPlayPercLenth);

 AppendText(form, "lR", m_arrRecordBuffer.length.toString());
 for (i=0; i<m_arrRecordBuffer.length; i++)
  {
   AppendRecordThing(form, i);
  }

 for (i=0; i<m_arrPlayBuffers.length; i++)
  {
   for (k=0; k<m_arrPlayBuffers[i].length; k++)
    {
     if (m_arrPlayBuffers[i][k] != null)
       AppendPlayThing(form, i, k);
    }
  }

 document.body.appendChild(form);
 form.submit();


}

function ProcessForm()
{
 var params=new URLSearchParams(location.search); // ?cf1=0 
 var cbo, cbos, vars;
 var i;
 var k;
 var v, v1;

 m_IsLoading=true;

 if (params.has("radIn") == true)
  {
   v = params.get("radIn");
   switch(v)
    {
     case "G": m_CurrentInstrument = m_Guitar;   document.getElementById("radGuitar").checked = true;   break;
     case "B": m_CurrentInstrument = m_Bass;     document.getElementById("radBass").checked = true;     break;
     case "M": m_CurrentInstrument = m_Mandolin; document.getElementById("radMandolin").checked = true; break;
     case "U": m_CurrentInstrument = m_Ukulele;  document.getElementById("radUkulele").checked = true;  break;
     case "K": m_CurrentInstrument = m_Keyboard; document.getElementById("radKeyboard").checked = true; break;
    }
  }

 cbos = ["cboGuitarCapo", "cboGuitarTune", "cboBassCapo", "cboBassTune", "cboMandolinCapo", "cboMandolinTune", "cboUkuleleCapo", "cboUkuleleTune", "cboStaveTime"];
 vars = ["cGC", "cGT", "cBC", "cBT", "cMC", "cMT", "cUC", "cUT", "cST"];

 for (i=0; i<cbos.length; i++)
  {
   if (params.has(vars[i]) == true)
    {
     v = params.get(vars[i]);
     cbo = document.getElementById(cbos[i]);
     for (k=0; k<cbo.options.length; k++)
      {
       if (cbo.options[k].value == v)
         cbo.selectedIndex = k; 
      }
    }
  } 

 if (params.has("cT") == true)
  {
   v = parseInt(params.get("cT"));
   document.getElementById("cboStaveTime").selectedIndex = v;
   eventCboTimeSignature_Change();
  }

 if (params.has("rB") == true)
  {
   v = parseInt(params.get("rB"));
   document.getElementById("beatsPerMinute").value = v;
   eventSliderBPM();
  }

 if (params.has("rD") == true)
  {
   v = parseFloat(params.get("rD"));
   document.getElementById("audioLengthRecord").value = v;
   eventSliderLength();
  }

 if (params.has("lR") == true)
  {
   m_arrRecordBuffer = [];
   v = parseInt(params.get("lR"));
   if (v > 100  || v<0) // someone messing with args?
     return;  
   for (k=0; k<v; k++)
    {
     ReadRecordThing(params, k);
    }
   ShowRecordBuffer();
  }

 m_arrPlayBuffers = [];
 for(i=0; i<5; i++)
  {
   m_arrPlayBuffers[i] = [];
   for (k=0; k<m_PlaySixteenthCount; k++)
    {
     m_arrPlayBuffers[i][k] = null;
     ReadPlayThing(params, i, k);
    }
  }
 ShowPlayBuffer();
}

// call the constructors

 makeInstruments();
 makeModes();
 makeScales();
 makeMidiNotes();
 makeChordPatterns();
 makeChordPatternPlacements();
 makeBarreChordPatterns();

 makeGuitar(); // E2, A2, D3, G3, B3, E4

 makeBass(); // E1, A1, D2, G2

 makeMandolin(); // G3, D4, A4, E5

 makeUkulele(); //  G4, C4, E4, A4

</script>

</head>

<body>
<div class="dialogBase" id="divDialogBase" onclick="eventDialogChordPattern_Click(-1);">
 <div class="dialog" id="divDialog"></div>
</div>
<button class="tabLink" style="width: 10%; font-size: 2.1vw;" onclick="openPage(0, 'divProperties', this);" id="btnDefault">&#9728;</button>
<button class="tabLink" style="width:24%;" onclick="openPage(1, 'divTabHarmony', this)">Harmony</button>
<button class="tabLink" style="width:22%;" onclick="openPage(2, 'divTabChords', this)">Chords</button>
<button class="tabLink" style="width:22%;" onclick="openPage(3, 'divTabScales', this)">Scales</button>
<button class="tabLink" style="width:22%;" onclick="openPage(4, 'divTabRecord', this)">Compose</button>

<div id="divProperties" class="tabContent">
<table>
 <tr>
  <th></th>
  <th class="thInst">Instrument</th>
  <th class="thInst">Capo</th>
  <th class="thInst">Tuning</th>
 </tr>
 <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radGuitar" class="radBtn" onclick="eventRadInstrument(m_Guitar);"></td>
  <td class="tdInst">Guitar</td>
  <td><select id="cboGuitarCapo" onchange="eventcboGuitarCapo_Change();"></select></td>
  <td><select id="cboGuitarTune" onchange="eventcboGuitarTune_Change();"></select></td>
 </tr>
 <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radBass" class="radBtn" onclick="eventRadInstrument(m_Bass);"></td>
  <td class="tdInst">Bass</td>
  <td><select id="cboBassCapo" onchange="eventcboBassCapo_Change();"></select></td>
  <td><select id="cboBassTune" onchange="eventcboBassTune_Change();"></select></td>
 </tr>
 <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radMandolin" class="radBtn" onclick="eventRadInstrument(m_Mandolin);"></td>
  <td class="tdInst">Mandolin</td>
  <td><select id="cboMandolinCapo" onchange="eventcboMandolinCapo_Change();"></select></td>
  <td><select id="cboMandolinTune" onchange="eventcboMandolinTune_Change();"></select></td>
 </tr>
 <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radUkulele" class="radBtn" onclick="eventRadInstrument(m_Ukulele);"></td>
  <td class="tdInst">Ukulele</td>
  <td><select id="cboUkuleleCapo" onchange="eventcboUkuleleCapo_Change();"></select></td>
  <td><select id="cboUkuleleTune" onchange="eventcboUkuleleTune_Change();"></select></td>
 </tr>
  <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radKeyboard" class="radBtn" onclick="eventRadInstrument(m_Keyboard);"></td>
  <td class="tdInst">Keyboard</td>
  <td class="tdInst" colspan=2>Chord Fingering Option
    <input type="radio" name="Fingering" id="radFingeringNumbers" class="radBtn" onclick="eventRadFingering(optFingeringNumbers);"> Numbers
    <input type="radio" name="Fingering" id="radFingeringLetters" class="radBtn" onclick="eventRadFingering(optFingeringLetters);"> Letters
  </td>
 </tr>
 <tr>
  <td colspan=2><span class="tdHarmonyInst">Audio Settings: </span>
   <select id="cboAudioWave" onchange="eventcboAudioWave_Change();">
    <option selected value="square">Square</option>
    <option value="sine">Sine</option>
    <option value="sawtooth">Sawtooth</option>
    <option value="triangle">Triangle</option>
   </select>
  </td>
  <td colspan=2>
    &nbsp; &nbsp; <input type="range" id="audioVolumeControl" min="0" max="1" value="0.2" step="0.01" onchange="eventSliderMaster();" /> &nbsp; <span id="spanMasterVol" class="fretMark"></span> &nbsp; &nbsp;
    <input type="button" class="btn" value="Test" onclick="TestVolume();">
  </td>
 </tr>
 <tr>
  <td colspan=4>&nbsp;</td>
 </tr>
 <tr>
  <td colspan=4 class="tdVersion">Developer Discord Channel: <a target="_blank" href="https://discord.gg/6auAGhj"> https://discord.gg/6auAGhj </a></td>
 </tr>
 <tr>
  <td colspan=4 class="tdVersion" id="tdVersion"></td>
 </tr>
</table>
</div>

<div id="divTabHarmony" class="tabContent">
<table>
 <tr valign=middle>
  <td><select id="cboModesTH" onchange="eventCboModesTH_Change();"></select></td>
  <td><select id="cboKeysTH" title="Choose Key" onchange="eventCboKeysTH_Change();"></select></td>
  <td id='tdModeChordsTH'></td>
  <td id='tdHarmonyInstrument' class='tdHarmonyInst'></td>
 </tr>
</table>
<table>
 <tr>
  <td>
   <table>
    <tr>
     <td class="tdSideChord"></td>
     <td id="tdScaleInst"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord0" class="tdSideChord"></td>
     <td id="tdChordInst0"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord1" class="tdSideChord"></td>
     <td id="tdChordInst1"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord2" class="tdSideChord"></td>
     <td id="tdChordInst2"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord3" class="tdSideChord"></td>
     <td id="tdChordInst3"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord4" class="tdSideChord"></td>
     <td id="tdChordInst4"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord5" class="tdSideChord"></td>
     <td id="tdChordInst5"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord6" class="tdSideChord"></td>
     <td id="tdChordInst6"></td>
    </tr>
   </table>
 </td>
 </tr>
</table>
</div>

<div id="divTabChords" class="tabContent">
<table>
 <tr valign=middle>
  <td><select id="cboModesChord" onchange="eventCboModesChord_Change();"></select></td>
  <td><select id="cboKeysChord" title="Choose Key" onchange="eventCboKeysChord_Change();"></select></td>
  <td id='tdChordRoots'></td>
  <td><input class="btn" type="button" value="Clear" onclick="eventBtnChordClear_Click();">
 </tr>
 <tr>
  <td colspan=4 id="tdChordAllNoteRoots"></td>
 </tr>
</table>
<table id="tableChords">
</table>
</div>

<div id="divTabScales" class="tabContent">
<table>
 <tr valign=middle>
  <td><select id="cboModesScale" onchange="eventcboModesScale_Change();"></select></td>
  <td><select id="cboKeysScale" title="Choose Key" onchange="eventcboKeysScale_Change();"></select></td>
  <td><input class="btn" type="button" value="Add" onclick="eventBtnScaleAdd_Click();"></td>
  <td><input class="btn" type="button" value="Clear" onclick="eventBtnScaleClear_Click();"></td>
 </tr>
 <tr valign=middle>
  <td colspan=2><select id="cboOtherScales" onchange="eventcboOtherScales_Change();"></select></td>
  <td><input class="btn" type="button" value="Add" onclick="eventBtnOtherScaleAdd_Click();"></td>
  <td>&nbsp;</td>
 </tr>
</table>
<table id="tableScales">
</table>
</div>

<div id="divTabRecord" class="tabContent" style="overflow-x:hidden;">
<table>
 <tr>
  <td style="width:100vw;">
   <table>
    <tr>
     <td align=center>
      <table>
       <tr><td>
        <select id="cboTime">
         <option value=1>Whole</option>
         <option value=2>Half</option>
         <option value=4 selected="selected">1/4</option>
         <option value=8>1/8</option>
         <option value=16>1/16</option>
        </select>
      </td></tr>
      <tr><td>
       <input type="range" id="audioVolumeRecord" style="width:5.3vw; font-size:2.2vw;" min="0" max="1" value="0.3" step="0.01" onchange="eventSliderVol();">&nbsp;<span id="spanVol" class="fretMark">0.3</span>
      </td></tr>
      </table>
     </td>
     <td><div style="max-width:77vw; width:77vw; height:8.9vw; border:0.052vw solid blue; white-space:nowrap; overflow-x:scroll;" id="divRecordBuffer"> </div></td>
     <td>
      <table>
       <tr><td class="tdRec"><input type="checkbox" name="choose" class="radBtn" id="chkRecord" onclick="eventChkRecord_Click();"><label for="chkRecord">Choose</label></td></tr>
       <tr><td class="tdRec"><input class="btn" type="button" style="width:8.7vw;" value="Clear" onclick="eventBtnRecordClear_Click();"></td></tr>
      </table>
    </tr>
   </table>
  </td>
 </tr>
</table>
<div style="border:0.1vw solid blue;">
 <table>
  <tr>
   <td>
    <table>
     <tr>
      <td>
       <select id="cboStaveTime" onchange="eventCboTimeSignature_Change();">
        <option value="1" selected="selected">4/4 Time</option>
        <option value="2">3/4 Time</option>
        <option value="3">2/4 Time</option>
        <option value="4">6/8 Time</option>
       </select>
      </td>
     </tr>
     <tr><td><input type="range" id="beatsPerMinute" style="width:7.1vw; font-size:1.2vw;" min="40" max="200" value="100" step="1" onchange="eventSliderBPM();" />&nbsp;<span id="spanBPM" class="fretMark">100</span></td></tr>
     <tr><td><input type="range" id="audioLengthRecord" style="width:7.1vw; font-size:1.2vw;" min="0.2" max="1" value="0.5" step="0.1" onchange="eventSliderLength();">&nbsp;<span id="spanLength" class="fretMark">0.5</span></td></tr>
     <tr><td><input type="button" class="btnBuff" style="color:darkblue;"  value="Clear" onclick='eventBtnClearSelectedBuffer();'></td></tr>
     <tr><td><input type="button" class="btnBuff" style="color:#024020;" id="btnPlay" value="Play" onclick='eventBtnPlayBuffers();'></td></tr>
     <tr><td><input type="button" class="btnBuff" id="btnSubmit" value="Bookmark" onclick='eventBtnSubmit();'></td></tr> 
    </table>
   </td>
   <td style="width:86vw; max-width:85vw; overflow-x:hidden;">
    <div style="overflow-x:scroll;">
    <table>
     <tr>
      <td><input type="radio" class="radBtn" style="accent-color:darkblue;" name="radPlayBuffer" id="radPlayBuffer0" value="0" onclick="eventRadPlayBufferSelect(0);"></td>
      <td><input type="checkbox" class="radBtn" style="accent-color:#024020;" id="chkPlayBuffer0" checked value="0"></td>
      <td class="tdPlayBuffer" id="tdPlayBuffer0"></td>
     </tr>
     <tr>
      <td><input type="radio" class="radBtn" style="accent-color:darkblue;" name="radPlayBuffer" id="radPlayBuffer1" value="1" onclick="eventRadPlayBufferSelect(1);"></td>
      <td><input type="checkbox" class="radBtn" style="accent-color:#024020;" id="chkPlayBuffer1" checked value="0"></td>
      <td class="tdPlayBuffer" id="tdPlayBuffer1"></td>
     </tr>
     <tr>
      <td><input type="radio" class="radBtn" style="accent-color:darkblue;" name="radPlayBuffer" id="radPlayBuffer2" value="2" onclick="eventRadPlayBufferSelect(2);"></td>
      <td><input type="checkbox" class="radBtn" style="accent-color:#024020;" id="chkPlayBuffer2" checked value="0"></td>
      <td class="tdPlayBuffer" id="tdPlayBuffer2"></td>
     </tr>
     <tr>
      <td><input type="radio" class="radBtn" style="accent-color:darkblue;" name="radPlayBuffer" id="radPlayBuffer3" value="3" onclick="eventRadPlayBufferSelect(3);"></td>
      <td><input type="checkbox" class="radBtn" style="accent-color:#024020;"  id="chkPlayBuffer3" checked value="0"></td>
      <td class="tdPlayBuffer" id="tdPlayBuffer3"></td>
     </tr>
     <tr>
      <td><input type="radio" class="radBtn" style="accent-color:darkblue;" name="radPlayBuffer" id="radPlayBuffer4" value="4" onclick="eventRadPlayBufferSelect(4);"></td>
      <td><input type="checkbox" class="radBtn" style="accent-color:#024020;"  id="chkPlayBuffer4" checked value="0"></td>
      <td class="tdPlayBuffer" id="tdPlayBuffer4"></td>
     </tr>
    </table>
   </div>
   </td>
  </tr>
 </table>
</div>
<br>
<div id="divPlayInst">
</div>
</div>

<script type="text/javascript">

 // after document is loaded 

 document.getElementById("btnDefault").click();                    // open default tab
 document.getElementById("radGuitar").checked = true;              // default guitar
 document.getElementById("radFingeringNumbers").checked = true;    // default chord fingering numbers instead of letters

 eventRadFingering(optFingeringNumbers);                           // loads the fingering placement values
 m_CurrentInstrument = m_Guitar;                                   // set current instrument

 dynaCapoLoader();   // load instrument capos
 dynaTuneLoader();   // load instrument alt tuning

 
 dynaModesLoaderTH();        
 THShowChords();

 dynaModesLoaderChord();    // chords tab
 dynaChordsAllRootsButtons();             

 dynaModesLoaderScale();    // scale tab
 dynaOtherScaleLoader();

 document.getElementById("tdVersion").innerHTML = "Music Reference Copyright © 2023 Brian L Hughes Version " + m_Version;

 document.getElementById("radPlayBuffer0").checked = true;  // 1st compose buffer selector

 eventCboTimeSignature_Change();   // sets default time signatuire

 eventSliderMaster();
 eventSliderVol();
 eventSliderLength();
 eventSliderBPM();                 

 m_PlaySixteenthIndex = -1;

 ProcessForm();
 

</script>
</body>
</html>